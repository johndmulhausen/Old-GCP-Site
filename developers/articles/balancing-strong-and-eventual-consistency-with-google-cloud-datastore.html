<!DOCTYPE html>
<html lang="en" class="maia">
  <head>
    <title>Balancing Strong and Eventual Consistency with Google Cloud Datastore - Google Cloud Platform</title>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="/_static/images/favicon.ico">
    <link rel="apple-touch-icon" href="/_static/images/apple-touch-icon.png">
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700' rel='stylesheet' type='text/css'>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>

    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->

    <title>Cloud Computing &amp; Cloud Hosting Services — Google Cloud Platform</title>
    <meta name="google-site-verification" content="8dOEM3Xenm6yaBc83y2WKgqQG0iHI7Ph6Rl_YLIZLQ8" />

    <!-- GSAP animation frameworks -->
    <script src="//www.gstatic.com/external_hosted/gsap/TweenMax.min.js"></script>
    <script src="//www.gstatic.com/external_hosted/gsap/TimelineMax.min.js"></script>
    <script src="/js/floodlight.js"></script>
    <meta name="viewport" content="initial-scale=1, minimum-scale=1, width=device-width">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,300,400,600,700" rel="stylesheet">

    <link href="//www.google.com/css/maia.experimental.css" rel="stylesheet">
    <link href="/css/maia-cloud.css" rel="stylesheet"/>
    <link href="/css/default.css" rel="stylesheet">
  </head>
  <body>
  <div id="maia-header">
    <div class="maia-aux">
      <h1><a href="/"><img src="/images/gcp-logo.png" alt="Cloud Platform" data-retina="383x48"></a></h1>

<div class="search-container">
  
  <form action="/search" class="maia-search">
    <input type="text" placeholder="Search this site" name="q">
    <button class="maia-button" type="submit" data-g-event="Maia: Button" data-g-action="Maia: Primary – Header" data-g-label="Search">
      <span class="maia-search-icon">Search</span>
    </button>
  </form>
  <div class="cloud-social">
    <div class="cloud-signed-out">
      <!-- <a href="/console" class="cp-track" id="try-header">Sign in</a> -->
    </div>
  </div>
</div>

    </div>
  </div>
  <div id="maia-nav-x" class="maia-nav">
    <div class="maia-aux">
   <div class="cp-cta">
   <a class="cp-track maia-button maia-button-secondary white-button" href="/contact/">Contact sales</a>
   <a class="cp-track maia-button blue-button" href="https://console.developers.google.com?getstarted=https://cloud.google.com" style="color: #ffffff;">Try it now</a>
   </div>
      <ul>
        <li id="home-nav"
            
              class="active"
            >

            <a 
              class="active"
             href="index.html" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Home"> 
            Home
            </a>
        </li>      
        <li
            >
            <a href="/why-google/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Why Google"> 
            Why Google
            </a>
        </li>
        <li id="main-nav-product-dropdown" class="dropdown">
            <a href="/products/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Products"> 
            Products
            </a>
        </li>
        <li
            >
            <a href="/solutions/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Solutions"> 
            Solutions
            </a>
        </li>
        <li
            >
            <a href="/customers/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Customers"> 
            Customers
            </a>
        </li>
        <li
            >
            <a href="/developers/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Developers"> 
            Developers
            </a>            
        </li>
        <li
            >
            <a href="/support/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Support"> 
            Support
            </a>            
        </li>
        <li>
            <a href="/partners/" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Partners"> 
            Partners
            </a>            
        </li>
        <li>
            <a href="https://github.com/GoogleDevDocs/googledevdocs.github.io/edit/master/developers/articles/balancing-strong-and-eventual-consistency-with-google-cloud-datastore.html" event="autotrack-data-g" data-g-event="Global Nav" data-g-action="Nav Bar" data-g-label="Edit Page"> 
            Edit Page
            </a>            
        </li>
      </ul>
    </div>
  </div>

<!-- Products subnav -->
<div id="maia-nav-x" class="maia-nav products-nav">
  <div class="maia-aux">
    <div class="products-nav-dropdown maia-cols">

      <div id="compute-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Compute</span>
        <div class="dropdown-item-container">
          <a href="/products/compute-engine/">
            <span class="product-name">Compute Engine</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/app-engine/">
            <span class="product-name">App Engine</span>
          </a>
        </div>
      </div>

      <div id="storage-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Storage</span>
        <div class="dropdown-item-container">
          <a href="/products/cloud-sql/">
            <span class="product-name">Cloud SQL</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/cloud-storage/">
            <span class="product-name">Cloud Storage</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/cloud-datastore/">
            <span class="product-name">Cloud Datastore</span>
          </a>
        </div>
      </div>

      <div id="big-data-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Big Data</span>
        <div class="dropdown-item-container">
          <a href="/products/bigquery/">
            <span class="product-name">BigQuery</span>
          </a>
        </div>
      </div>

      <div id="services-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Services</span>
        <div class="dropdown-item-container">
          <a href="/products/cloud-dns/">
            <span class="product-name">Cloud DNS</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/cloud-endpoints/">
            <span class="product-name">Cloud Endpoints</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/translate-api/">
            <span class="product-name">Translate API</span>
          </a>
        </div>
        <div class="dropdown-item-container">
          <a href="/products/prediction-api/">
            <span class="product-name">Prediction API</span>
          </a>
        </div>
      </div>

      <div id="management-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Management</span>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/products/cloud-deployment-manager/">Cloud Deployment Manager</a></span>
        </div>
      </div>

      <div id="pricing-dropdown" class="products-column maia-col-2">
        <span class="product-list-title">Pricing</span>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/products/pricing/">Overview</a></span>
        </div>
        <div class="dropdown-item-container">
          <span class="product-name"><a href="/products/calculator/">Calculator</a></span>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="maia-main" class="cp-article">
  <div class="maia-cols">
    <div class="maia-col-9">
      <div>
        <div style="float:right">
          <div class="g-plusone"></div>
        </div>
        <h1 class="title">Balancing Strong and Eventual Consistency with Google Cloud Datastore</h1>
      </div>
      
<div class="cp-article-tutorial">


  <h2><a name="h.4n3hcboreol0" id="h.4n3hcboreol0"></a>Providing a Consistent User Experience and Leveraging the Eventual Consistency Model to Scale to Large Datasets</h2>
  <p>This document discusses achieving strong consistency for a positive user experience, while embracing Google Cloud Datastore&rsquo;s eventual consistency model for handling large quantities of data and users.</p>
  <p>This document is intended for software architects and engineers wanting to build solutions on Google Cloud Datastore. To help readers who are more familiar with relational databases than non-relational systems like Google Cloud Datastore, this document points out analogous concepts in relational databases. The document assumes that you have a basic familiarity with Google Cloud Datastore. The easiest way to get started with Google Cloud Datastore is in Google App Engine using one of the supported languages, Python, Java, Go, or PHP. If you have not yet used App Engine, we suggest you first read the <a href="https://developers.google.com/appengine/">Getting Started Guide</a> and the <a href="https://developers.google.com/appengine/docs/python/storage">Storing Data</a> section for one of those languages. Though Python is used for example code fragments, no Python expertise is required in order to follow along with this document.</p>

  <h4>Contents</h4>
  <p>
    <a class="indnt" href="#h.w3kz4fze562t">NoSQL and Eventual Consistency</a><br>
    <a class="indnt" href="#h.tf76fya5nqk8">Eventual Consistency in Google Cloud Datastore</a><br>
    <a class="indnt" href="#h.3loc7ynqbw6i">Ancestor Query and Entity Group</a><br>
    <a class="indnt" href="#h.ooaauy74mue8">Limitations of Entity Group and Ancestor Query</a><br>
    <a class="indnt" href="#h.k31yisins6ul">Alternatives to Ancestor Queries</a><br>
    <a class="indnt" href="#h.buvz7spe7ytk">Minimizing Time to Achieve Full Consistency</a><br>
    <a class="indnt" href="#h.njxgygqflg9k">Conclusion</a><br>
    <a class="indnt" href="#h.ywh7cedcuhkk">Additional Resources</a>
  </p>


  <h2><a name="h.w3kz4fze562t" id="h.w3kz4fze562t"></a>NoSQL and Eventual Consistency</h2>
  <p>Non-relational databases, also known as NoSQL databases, have emerged in recent years as an alternative to relational databases. Google Cloud Datastore is one of the most widely used non-relational databases in the industry. In 2013 Google Cloud Datastore processed 4.5 trillion transactions per month (<a href="http://googlecloudplatform.blogspot.com/2013/05/reducing-app-engine-datastore-pricing-by-up-to-25-percent.html">Google Cloud Platform blog post</a>). It provides a simplified way for developers to store and access data. The flexible schema maps naturally to object-oriented and scripting languages. Google Cloud Datastore also provides a number of features that relational databases are not optimally suited to provide, including high-performance at a very large scale and high-reliability. </p>
  <p>To developers more accustomed to relational databases, it may be challenging to design a system that leverages non-relational databases, as some characteristics and practices of non-relational databases may be relatively unfamiliar to them. Although the Google Cloud Datastore programming model is simple, it is important to be aware of these characteristics. Eventual consistency is one of these characteristics and programming for eventual consistency is the main subject of this document.</p>

  <h3><a name="h.86naen3bqe0" id="h.86naen3bqe0"></a>What is Eventual Consistency?</h3>
  <p><span class="bld">Eventual consistency</span> is a theoretical guarantee that, provided no new updates to an entity are made, all reads of the entity will eventually return the last updated value. The Internet Domain Name System (DNS) is a well-known example of a system with an eventual consistency model. DNS servers do not necessarily reflect the latest values but, rather, the values are cached and replicated across many directories over the Internet. It takes a certain amount of time to replicate modified values to all DNS clients and servers. However, the DNS system is a very successful system that has become one of the foundations of the Internet. It is highly available and has proven to be extremely scalable, enabling name lookups to over a hundred million devices across the entire Internet.</p>
  <p>Figure 1 illustrates the concept of replication with eventual consistency. The diagram illustrates that although replicas are always available to read, some replicas may be inconsistent with the latest write on the originating node, at a particular moment in time. In the diagram, Node A is the originating node and nodes B and C are the replicas.</p>

  <figure>
    <img src="/images/articles/balancing-strong-and-eventual-consistency-with-gcd/eventual-consistency.png">
    <figcaption>Figure 1: Conceptual Depiction of Replication with Eventual Consistency</figcaption>
  </figure>

  <p>In contrast, traditional relational databases have been designed based on the concept of strong consistency, also called immediate consistency. This means that data viewed immediately after an update will be consistent for all observers of the entity. This characteristic has been a fundamental assumption for many developers who use relational databases. However, to have strong consistency, developers must compromise on the scalability and performance of their application. Simply put, data has to be locked during the period of update or replication process to ensure that no other processes are updating the same data.</p>
  <p>A conceptual view of the deployment topology and replication process with strong consistency is shown in Figure 2. In this diagram, you can see how replicas always have values consistent with the originating node, but are not accessible until the update finishes.</p>

  <figure>
    <img src="/images/articles/balancing-strong-and-eventual-consistency-with-gcd/strong-consistency.png">
    <figcaption>Figure 2: Conceptual Depiction of Replication with Strong Consistency</figcaption>
  </figure>

  <h3><a name="h.rcbsdmar23fq" id="h.rcbsdmar23fq"></a>Balancing Strong and Eventual Consistency</h3>
  <p>Non-relational databases have become popular recently, especially for web applications that require high-scalability and performance with high-availability. Non-relational databases let developers choose an optimal balance between strong consistency and eventual consistency for each application. This allows developers to combine the benefits of both worlds. For example, information such as &ldquo;knowing who in your buddy list is online at given time&rdquo; or &ldquo;knowing how many users have +1&rsquo;d your post&rdquo; are use cases where strong consistency is not required. Scalability and performance can be provided for these use cases by leveraging eventual consistency. Use cases which require strong consistency include information such as &ldquo;whether or not a user finished the billing process&rdquo; or &ldquo;the number of points a game player earned during a battle session&rdquo;.</p>
  <p>To generalize the examples just given, use cases with very large numbers of entities often suggest that eventual consistency is the best model. If there are very large number of results in a query, then the user experience may not be affected by the inclusion or exclusion of specific entities. On the other hand, use cases with a small number of entities and a narrow context suggest that strong consistency is required. The user experience will be affected because the context will make users aware of which entities should be included or excluded.</p>
  <p>For these reasons, it is important for developers to understand the non-relational characteristics of Google Cloud Datastore. The following sections discuss how eventual consistency and strong consistency models can be combined to build a scalable, highly available, and highly performing application. In doing so, consistency requirements for a positive user experience will still be satisfied.</p>

  <h2><a name="h.tf76fya5nqk8" id="h.tf76fya5nqk8"></a>Eventual Consistency in Google Cloud Datastore</h2>
  <p>The correct API must be selected when a strongly consistent view of data is required. The different varieties of Google Cloud Datastore query APIs and their corresponding consistency models are shown in Table 1.</p><a href="#" name="73aa40d03f7c0cd78a8b69d986cc7d802f3e49eb"></a><a href="#" name="2"></a>

  <figure>
    <table class="brdr-table" style="text-align:left;">
      <tbody>
        <tr>
          <th>
            <p>Google Cloud Datastore API</p>
          </th>
          <th>
            <p>Read of entity value</p>
          </th>
          <th>
            <p>Read of index</p>
          </th>
        </tr>
        <tr>
          <td>
            <p><a href="https://developers.google.com/appengine/docs/python/datastore/queries">Global Query</a></p>
          </td>
          <td>
            <p>Eventual consistency</p>
          </td>
          <td>
            <p>Eventual consistency</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><a href="https://developers.google.com/appengine/docs/python/datastore/queries#Python_Keys_only_queries">Keys-only Global Query</a></p>
          </td>
          <td>
            <p>N/A</p>
          </td>
          <td>
            <p>Eventual consistency</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><a href="https://developers.google.com/appengine/docs/python/datastore/queries#Python_Ancestor_queries">Ancestor Query</a></p>
          </td>
          <td>
            <p>Strong consistency</p>
          </td>
          <td>
            <p>Strong consistency</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><a href="https://developers.google.com/appengine/docs/python/datastore/entities#Python_Retrieving_an_entity">Lookup by key</a> (get())</p>
          </td>
          <td>
            <p>Strong consistency</p>
          </td>
          <td>
            <p>N/A</p>
          </td>
        </tr>
      </tbody>
    </table>
    <figcaption>Table 1: Google Cloud Datastore queries/get calls and possible consistency behaviors</figcaption>
  </figure>

  <p>Google Cloud Datastore queries without an ancestor are known as <span class="bld">global queries</span> and are designed to work with an eventual consistency model. This does not guarantee strong consistency. A <span class="bld">keys-only</span> global query is a <span class="bld">global query</span> that returns only the keys of entities matching the query, not the attribute values of the entities. An <span class="bld">ancestor query</span> scopes the query based on an ancestor entity. The following sections cover each consistency behavior in more detail.</p>

  <h3><a name="h.cb1okox563r3" id="h.cb1okox563r3"></a>Eventual Consistency when Reading Entity Values</h3>
  <p>With the exception of ancestor queries, an updated entity value may not be immediately visible when executing a query. To understand the impact of eventual consistency when reading entity values, consider a scenario where an entity, Player, has a property, Score. Consider, for example, that the initial Score has a value of 100. After some time, the Score value is updated to 200. If a global query is executed and includes the same Player entity in the result, it is possible that the value of the property Score of the returned entity might appear unchanged, at 100.</p>
  <p>This behavior is caused by the replication between Google Cloud Datastore servers. Replication is managed by Bigtable and Megastore, the underlying technologies for Google Cloud Datastore (see <a href="#h.ywh7cedcuhkk">Additional Resources</a> for more on details Bigtable and Megastore). The replication is executed with the <a href="http://en.wikipedia.org/wiki/Paxos_(computer_science)">Paxos</a> algorithm, which synchronously waits until a majority of the replicas have acknowledged the update request. The replica is updated with data from the request after a period of time. This time period is usually small, but there is no guarantee on its actual length. A query may read the stale data if it is executed before the update finishes.</p>
  <p>In many cases, the update will have reached all the replicas very quickly. However, there are several factors that may, when compounded together, increase the time to achieve consistency. These factors include any datacenter-wide incidents that involve switching over a large number of servers between datacenters. Given the variation of these factors, it is impossible to provide any definitive time requirements for establishing full consistency.</p>
  <p>The time required for a query to return the latest value is usually very short. However, in rare situations when the replication latency increases, the time can be much longer. Applications that use Google Cloud Datastore global queries should be carefully designed to handle these cases gracefully.</p>
  <p>The eventual consistency on reading entity values can be avoided by using a keys-only query, an ancestor query, or lookup by key (the get() method). We will discuss these different types of queries in more depth below.</p>

  <h3><a name="h.4xdytk3hj44" id="h.4xdytk3hj44"></a>Eventual Consistency on Reading an Index</h3>
  <p>An index may not yet be updated when a global query is executed. This means that, even though you may able to read the latest property values of the entities, the &ldquo;list of entities&rdquo; included in the query result may be filtered based on old index values.</p>
  <p>To understand the impact of eventual consistency on reading an index, imagine a scenario where a new entity, Player, is inserted into Google Cloud Datastore. The entity has a property, Score, which has an initial value of 300. Immediately after the insertion, you execute a keys-only query to fetch all entities with a Score value greater than 0. You would then expect the Player entity, just recently inserted, to appear in the query results. Perhaps unexpectedly, instead, you may find that the Player entity does not appear in the results. This situation can occur when the index table for the Score property is not updated with the newly inserted value at the time of the query execution.</p>
  <p>Remember that all the queries in Google Cloud Datastore are executed against <a href="https://developers.google.com/appengine/docs/python/datastore/indexes#Python_Index_definition_and_structure">index tables</a>, and yet <a href="https://developers.google.com/appengine/articles/life_of_write">the updates to the index tables are asynchronous</a>. Every entity update is, essentially, made up of two phases. In the first phase, the commit phase, a write to the transaction log is performed. In the second phase, data is written and indexes are updated. If the commit phase succeeds, then the write phase is guaranteed to succeed, though it might not happen immediately. If you query an entity before the indexes are updated, you may end up viewing data that is not yet consistent.</p>
  <p>As a result of this two phase process, there is a time delay before the latest updates to entities are visible in global queries. Just as with entity value eventual consistency, the time delay is typically small, but may be longer (even minutes or more in exceptional circumstances).</p>
  <p>The same thing can happen after updates as well. For example, suppose you update an existing entity, Player, with a new Score property value of 0, and executed the same query immediately afterwards. You would expect the entity not to appear in the query results because the new Score value of 0 would exclude it. However, due to the same asynchronous index update behavior, it is still possible for the entity to be included in the result.</p>
  <p>The eventual consistency on reading an index can be only be avoided by using an ancestor query or lookup by key method. A keys-only query can not avoid this behavior.</p>

  <h3><a name="h.ubkfi6o13a4f" id="h.ubkfi6o13a4f"></a>Strong Consistency on Reading Entity Values and Indexes</h3>
  <p>In Google Cloud Datastore, there are only two APIs that provide a strongly consistent view for reading entity values and indexes: (1) the lookup by key method and (2) the ancestor query. If application logic requires strong consistency, then the developer should use one of these methods to read entities from Google Cloud Datastore.</p>
  <p>Google Cloud Datastore is specifically designed to provide strong consistency on these APIs. When calling either one of them, Google Cloud Datastore will flush all pending updates on one of the replicas and index tables, then execute the lookup or ancestor query. Thus, the latest entity value, based on the updated index table, will always be returned with values based on the latest updates.</p>
  <p>The lookup by key call, in contrast to queries, only returns one entity or a set of entities specified by a key or a set of keys. This means that an ancestor query is the only way in Google Cloud Datastore to satisfy strong consistency requirement together with a filtering requirement. However, ancestor queries do not work without specifying an <span class="bld">entity group</span>.</p>

  <h2><a name="h.3loc7ynqbw6i" id="h.3loc7ynqbw6i"></a>Ancestor Query and Entity Group</h2>
  <p>As discussed at the beginning of this document, one of the benefits of Google Cloud Datastore is that developers can find an optimal balance between strong consistency and eventual consistency. In Google Cloud Datastore, an <a href="https://developers.google.com/appengine/docs/python/datastore/structuring_for_strong_consistency">entity group</a> is a unit with strong consistency, transactionality, and locality. By utilizing entity groups, developers can define the scope of strong consistency among the entities in an application. In this way, the application can maintain consistency inside the entity group while, at the same time, achieving high scalability, availability, and performance as a complete system.</p>
  <p>An entity group is a hierarchy formed by a root entity and its children or successors.<sup><a href="#ftnt1" name="ftnt_ref1" id="ftnt_ref1">[1]</a></sup> To create an entity group, a developer specifies an ancestor path, which is, essentially, a series of parent keys prefixing the child key. The concept of entity group is illustrated in Figure 3. In this case, the root entity with the key &ldquo;ateam&rdquo; has two children with the keys &ldquo;ateam/098745&rdquo; and &ldquo;ateam/098746&rdquo;.</p>

  <figure>
    <img src="/images/articles/balancing-strong-and-eventual-consistency-with-gcd/croup-concept.png">
    <figcaption>Figure 3: Schematic View of Entity Group Concept</figcaption>
  </figure>

  <p>Inside the entity group, the following characteristics are guaranteed:</p>
  <ul>
    <li>
      Strong Consistency
      <ul>
        <li>An ancestor query on the entity group will return a strongly consistent result. In this way, it reflects the latest entity values filtered by the latest index state.</li>
      </ul>
    </li>
    <li>
      Transactionality
      <ul>
        <li>By demarcating a transaction programmatically, the entity group provides ACID (atomicity, consistency, isolation, and durability) characteristics in the transaction.</li>
      </ul>
    </li>
    <li>
      Locality
      <ul>
        <li>Entities in an entity group will be stored at physically close places on Google Cloud Datastore servers, because all the entities are sorted and stored by the lexicographical order of the keys. This enables an ancestor query to rapidly scan the entity group with minimal I/O.</li>
      </ul>
    </li>
  </ul>

  <p>An ancestor query is a special form of query that only executes against a specified entity group. It executes with strong consistency. Behind the scenes, Google Cloud Datastore assures that all the pending replications and index updates are applied before executing the query.</p>

  <h3><a name="h.pyro8j6ki6tn" id="h.pyro8j6ki6tn"></a>Ancestor Query Example</h3>
  <p>This section describes how to use entity groups and ancestor queries in practice. In the following example, we consider the problem of managing data records for people. Suppose we have code that adds an entity of a specific kind followed immediately by a query on that kind. This concept is demonstrated by the example Python code below.</p>

<pre>
# Define the Person entity
class Person(db.Model):
    given_name = db.StringProperty()
    surname = db.StringProperty()
    organization = db.StringProperty()
# Add a person and retrieve the list of all people
class MainPage(webapp2.RequestHandler):
    def post(self):
        person = Person(given_name='GI', surname='Joe', organization='ATeam')
        person.put()
        q = db.GqlQuery("SELECT * FROM Person")
        people = []
        for p in q.run():
            people.append({'given_name': p.given_name,
                        'surname': p.surname,
                        'organization': p.organization})
</pre>

  <p>The problem with this code is that, in most cases, the query will not return the entity added in the statement above it. Since the query follows in the line following immediately after the insert, the index will not be updated when the query is executed. However, there is also a problem with validity of this use case: is there really a need to return a list of all people in one page with no context? What if there are a million people? The page would take too long to return.</p>
  <p>The nature of the use case suggests that we should provide some context to narrow the query. In this example, the context that we will use will be the organization. If we do that, then we can use the organization as an entity group and execute an ancestor query, which solves our consistency problem. This is demonstrated with the Python code below.</p>

<pre>
class Organization(db.Model):
    name = db.StringProperty()
class Person(db.Model):
    given_name = db.StringProperty()
    surname = db.StringProperty()
class MainPage(webapp2.RequestHandler):
    def post(self):
        org = Organization.get_or_insert('ateam', name='ATeam')
        person = Person(parent=org)
        person.given_name='GI'
        person.surname='Joe'
        person.put()
        q = db.GqlQuery("SELECT * FROM Person WHERE ANCESTOR IS :1 ", org)
        people = []
        for p in q.run():
            people.append({'given_name': p.given_name,
                        'surname': p.surname})
</pre>

  <p>This time, with the ancestor org specified in the GqlQuery, the query returns the entity just inserted. The example could be extended to drill down on an individual person by querying the person&rsquo;s name with the ancestor as part of the query. Alternatively, this could have also been done by saving the entity key and then using it to drill down with a lookup by key.</p>

  <h3><a name="h.l10xxpfjg70q" id="h.l10xxpfjg70q"></a>Maintaining Consistency Between Memcache and Google Cloud Datastore</h3>
  <p>Entity groups can also be used as a unit for maintaining consistency between Memcache entries and Google Cloud Datastore entities. For example, consider a scenario where you count the number of Persons in each team and store them in Memcache. To make sure the cached data is consistent with the latest values in Google Cloud Datastore, you can use <a href="https://developers.google.com/appengine/docs/python/datastore/metadataqueries#Python_Entity_group_metadata">entity group metadata</a>. The metadata returns the latest version number of specified entity group. You can compare the version number with the number stored in Memcache. Using this method you can detect a change in any of the entities in the entire entity group by reading from one set of metadata, instead of scanning all the individual entities in the group.</p>

  <h2><a name="h.ooaauy74mue8" id="h.ooaauy74mue8"></a>Limitations of Entity Group and Ancestor Query</h2>
  <p>The approach of using entity groups and ancestor queries is not a silver bullet. There are two challenges in practice that make it hard to apply the technique in general, as listed below.</p>

  <ol class="c28 lst-kix_qyusimaqza9q-0 start" start="1">
    <li>There is a limit of one update per second write for each entity group.</li>
    <li>The entity group relationship can not be changed after entity creation.</li>
  </ol>

  <h3><a name="h.8yrg89iapdjp" id="h.8yrg89iapdjp"></a>Write Limit</h3>
  <p>An important challenge is that the system must be designed to contain the number of updates (or transactions) in each entity group. The supported limit is one update per second per entity group.<sup><a href="#ftnt2" name="ftnt_ref2" id="ftnt_ref2">[2]</a></sup> If the number of updates needs to exceed that limit then the entity group may be a performance bottleneck.</p>
  <p>In the example above, each organization may need to update the record of any person in the organization. Consider a scenario where there are 1,000 people in the &ldquo;ateam&rdquo; and each person may have one update per second on any of the properties. As a result, there may be up to 1,000 updates per second in the entity group, a result which would not be achievable because of the update limit. This illustrates that it is important to choose an appropriate entity group design that considers performance requirements. This is one of the challenges of finding the optimal balance between eventual consistency and strong consistency.</p>

  <h3><a name="h.slap2zz3i3rk" id="h.slap2zz3i3rk"></a>Immutability of Entity Group Relationships</h3>
  <p>A second challenge is the immutability of entity group relationships. The entity group relationship is formed statically based on key naming. It cannot be changed after creating the entity. The only available option for changing the relationship is to delete the entities in an entity group and recreate them again. This challenge prevents us from using entity groups to define ad-hoc scopes for consistency or transactionality dynamically. Instead, the consistency and transactionality scope are closely tied with the static entity group defined at design time.</p>
  <p>For example, consider a scenario where you wish to implement a wire transfer between two bank accounts. This business scenario requires strong consistency and transactionality. However, the two accounts can not be grouped into one entity group last-minute or be based on a global parent. That entity group would create a bottleneck for the entire system that would hinder other wire transfer requests from being executed. So entity groups cannot be used in this way.</p>
  <p>However, there is an alternative way for a wire transfer to be implemented in a highly scalable and available way. One method to satisfy this requirement is to use <a href="https://developers.google.com/appengine/docs/python/datastore/#Python_Cross_group_transactions">Cross-group (XG) transactions</a> for transactionality and the Google Cloud Datastore lookup by key method or an ancestor query for consistency. Cross-group transactions are a Google Cloud Datastore feature that allows you to have  ACID characteristics for up to five entity groups or entities in one transaction. By using XG transactions, you can form a transaction scope dynamically with the two bank accounts at the time of request processing.</p>
  <p>Keep in mind that the XG transactions only ensure transactionality. To ensure strong consistency when reading the two bank accounts, you should use lookup by key method or an ancestor query. You will get an error if you try to execute a query that is not an ancestor query inside a transaction.</p>

  <h2><a name="h.k31yisins6ul" id="h.k31yisins6ul"></a>Alternatives to Ancestor Queries</h2>
  <p>If you already have an existing application with a large number of entities stored in Google Cloud Datastore, it may be difficult to incorporate entity groups afterwards in a refactoring exercise. It would require deleting all the entities and adding them within an entity group relationship. So, in data modeling for Google Cloud Datastore, it is important to make a decision on the entity group design in the early phase of the application design. Otherwise, you may be limited in refactoring to other alternatives to achieve a certain level of consistency, such as a keys-only query followed by a lookup-by-key, or by using Memcache.</p>

  <h3><a name="h.56geqhlrqja4" id="h.56geqhlrqja4"></a>Keys-only Global Query Followed by Lookup by Key</h3>
  <p>A keys-only global query is a special type of global query that returns only keys without the property values of the entities. Since the return values are only keys, the query does not involve an entity value with a possible consistency problem. A combination of the keys-only, global query with a lookup method will read the latest entity values. But it should be noted that a keys-only global query can not exclude the possibility of an index not yet being consistent at the time of the query, which may result in an entity not being retrieved at all. The result of the query could potentially be generated based on filtering out old index values. In summary, a developer may use a keys-only global query followed by lookup by key only when an application requirement allows the index value not yet being consistent at the time of a query.</p>

  <h3><a name="h.kzvtug7i4vlw" id="h.kzvtug7i4vlw"></a>Using Memcache</h3>
  <p>The Memcache service is volatile, but strongly consistent. So, by combining Memcache lookups and Google Cloud Datastore queries, it is possible to build a system that will be minimize consistency issues most of the time.</p>
  <p>For example, consider the scenario of a game application that maintains a list of Player entities, each with a score greater than zero.</p>

  <ul>
    <li>For insert or update requests, apply them to the list of Player entities in Memcache as well as Google Cloud Datastore</li>
    <li>For query requests, read the list of Player entities from Memcache and execute a keys-only query on Google Cloud Datastore when the list is not present in Memcache</li>
  </ul>

  <p>The returned list will be consistent whenever the cached list is present in Memcache. If the entry has been evicted, or the Memcache service is not available temporarily, the system may need to read the value from a Google Cloud Datastore query that could possibly return an inconsistent result. This technique can be applied to any application that tolerates a small amount of inconsistency.</p>
  <p>There are some best practices when using Memcache as a caching layer for Google Cloud Datastore:</p>

  <ul>
    <li>Catch Memcache exceptions and errors to maintain the consistency between the Memcache value and the Google Cloud Datastore value. If you receive an exception when updating the entry on Memcache, make sure to invalidate the old entry in Memcache. Otherwise there may be different values for an entity (an old value in Memcache and a new value in Google Cloud Datastore).</li>
    <li>Set an <a href="https://developers.google.com/appengine/docs/python/memcache/#Python_How_cached_data_expires">expiration period</a> on the Memcache entries. It is recommended to set short time periods for the expiration of each entry to minimize the possibility of inconsistency in the case of Memcache exceptions.</li>
    <li>Use <a href="https://developers.google.com/appengine/docs/python/memcache/#Python_Using_compare_and_set_in_Python">the compare-and-set</a> feature when updating the entries for concurrency control. This will help ensure that simultaneous updates on the same entry will not interfere with each other.</li>
  </ul>

  <h3><a name="h.ooddikjhrygc" id="h.ooddikjhrygc"></a>Gradual Migration to Entity Groups</h3>
  <p>The suggestions made in the previous section only lessen the possibility of inconsistent behavior. It is best to design the application based on entity groups and ancestor queries when strong consistency is required. However, it may not be feasible to migrate an existing application, which may include changing an existing data model and application logic from global queries to ancestor queries. One way to achieve this is by having a gradual transition process, such as the following:</p>

  <ol class="c28 lst-kix_gkyism9dw6ma-0 start" start="1">
    <li>Identify and prioritize the functions in the application that require strong consistency.</li>
    <li>Write new logic for insert() or update() functions using entity groups in addition to (rather than replacing) existing logic. In this way, any new inserts or updates on both new entity groups and old entities can be handled by an appropriate function.</li>
    <li>Modify the existing logic for read or query functions ancestor queries are executed first if a new entity group exists for the request. Execute the old global query as fallback logic if the entity group does not exist.</li>
  </ol>

  <p>This strategy allows for a gradual migration from an existing data model to a new data model based on entity groups that minimizes the risk of issues caused by eventual consistency. In practice, this approach is dependent on specific use cases and requirements for its application to an actual system.</p>

  <h3><a name="h.gj5afnup3sr9" id="h.gj5afnup3sr9"></a>Fallback to Degraded Mode</h3>
  <p>At present, it is difficult to detect a situation programmatically when an application has deteriorated consistency. However, in some cases, such as by monitoring customer support cases, it may be possible. If that is the case, then it may be possible to implement a degraded mode that could be turned on or off to disable some areas of application logic that require strong consistency. For example, rather than showing an inconsistent query result on a billing report screen, a maintenance message for that particular screen could be shown instead. In this way, the other services in the application can continue serving, and in turn, reduce the impact to the user experience.</p>

  <h2><a name="h.buvz7spe7ytk" id="h.buvz7spe7ytk"></a>Minimizing Time to Achieve Full Consistency</h2>
  <p>In a large application with millions of users or terabytes of Google Cloud Datastore entities, it is possible for inappropriate usage of Google Cloud Datastore to lead to deteriorated consistency. Such practices include:</p>

  <ul>
    <li>Sequential numbering in entity keys</li>
    <li>Too many indexes</li>
  </ul>

  <p>These practices do not affect small applications. However, once the application grows very large, these practices increase the possibility of longer times needed for consistency. So it is best to avoid them at the early stages of application design.</p>

  <h3><a name="h.rwk0fv57jze5" id="h.rwk0fv57jze5"></a>Anti-Pattern #1: Sequential Numbering of Entity Keys</h3>
  <p>Before the release of App Engine SDK 1.8.1, Google Cloud Datastore used a sequence of small integer IDs with generally consecutive patterns as the default auto-generated key names. In some documents this is referred to as a &ldquo;legacy policy&rdquo; for creating any entities that have no application specified key name. This legacy policy generated entity key names with sequential numbering, such as 1000, 1001, 1002, for example. However, as we have discussed earlier, Google Cloud Datastore stores entities by the lexicographical order of the key names, so that those entities will be are very likely stored on the same Google Cloud Datastore servers. If an application attracts really large traffic, this sequential numbering could cause a concentration of operations on a specific server, which may result in longer latency for consistency.</p>
  <p>In App Engine SDK 1.8.1, Google Cloud Datastore introduced a new ID numbering method with a default policy that uses scattered ID&rsquo;s (see <a href="https://developers.google.com/appengine/docs/python/datastore/entities#Python_Assigning_identifiers">reference</a> documentation). This default policy generates a random sequence of ID&rsquo;s up to 16 digits long that are approximately uniformly distributed. Using this policy, it is likely that the traffic of the large application will be better distributed among a set of Google Cloud Datastore servers with reduced time for consistency. The default policy is recommended unless your application specifically requires compatibility with the legacy policy.</p>
  <p>If you do explicitly set key names on entities, the naming scheme should be designed to access the entities evenly over the whole key name space. In other words, do not concentrate access in a particular range as they are ordered by the lexicographical order of key names. Otherwise, the same issue as with the sequential numbering may arise.</p>
  <p>To understand uneven distribution of access over the keyspace, consider an example where entities are created with the sequential key names as shown in the following code:</p>

<pre>
p1 = Person(key_name='0001')
p2 = Person(key_name='0002')
p3 = Person(key_name='0003')
...
</pre>

  <p>The application access pattern may create a &ldquo;hot spot&rdquo; over a certain range of the key names, such as having concentrated access on recently created Person entities. In this case, the frequently accessed keys will all have higher ID&rsquo;s. The load may then be concentrated on a specific Google Cloud Datastore server.</p>
  <p>Alternatively, to understand even distribution over the keyspace, consider using long random strings for key names. This is illustrated in the following example:</p>

<pre>
p1 = Person(key_name='t9P776g5kAecChuKW4JKCnh44uRvBDhU')
p2 = Person(key_name='hCdVjL2jCzLqRnPdNNcPCAN8Rinug9kq')
p3 = Person(key_name='PaV9fsXCdra7zCMkt7UX3THvFmu6xsUd')
...
</pre>

  <p>Now the recently created Person entities will be scattered over the keyspace and on multiple servers. This assumes that there is a sufficiently large number of Person entities.</p>

  <h3><a name="h.ou9y4doeg7dm" id="h.ou9y4doeg7dm"></a>Anti Pattern #2: Too Many Indexes</h3>
  <p>In Google Cloud Datastore, one update on an entity will lead to update on all indexes defined for that entity kind (see <a href="https://developers.google.com/appengine/articles/life_of_write">Life of a Datastore Write</a> for details). If an application uses many custom indexes, one update could involve tens, hundreds, or even thousands of updates on index tables. In a large application, an excessive use of custom indexes could result in increased load on the server and may increase the latency to achieve consistency.</p>
  <p>In most cases, custom indexes are added to support requirements such as customer support, troubleshooting, or data analysis tasks. Google <a href="/products/big-query">BigQuery</a> is a massively scalable query engine capable of executing ad-hoc queries on large datasets without pre-built indexes. It is better suited for use cases such as customer support, troubleshooting, or data analysis that require complex queries than Google Cloud Datastore.</p>
  <p>One practice is to combine Google Cloud Datastore and BigQuery to fulfill different business requirements. Use Google Cloud Datastore for online transactional processing (OLTP) required for core application logic and use Google BigQuery for online analytical processing (OLAP) for backend operations. It may be necessary to implement a continuous data export flow from Google Cloud Datastore to BigQuery to move the data for necessary those queries.</p>
  <p>Besides an alternate implementation for custom indexes, another recommendation is to specify unindexed properties explicitly (see <a href="https://developers.google.com/appengine/docs/python/ndb/properties#options">Property Options</a> in the reference documentation). By default, Google Cloud Datastore will create a different index table for each indexable property of an entity kind. If you have 100 properties on a kind, there will be 100 index tables for that kind, and an additional 100 updates on each update to an entity. A best practice, then, is to set properties unindexed where possible, if they are not needed for a query condition.</p>
  <p>Besides reducing the possibility of having increases times for consistency, these index optimizations may result in quite a large reduction of Google Cloud Datastore costs in a large application which heavily uses indexes.</p>

  <h2><a name="h.njxgygqflg9k" id="h.njxgygqflg9k"></a>Conclusion</h2>
  <p>Eventual consistency is an essential element of non-relational databases that allows developers to find an optimal balance between scalability, performance, and consistency. It is important to understand how to handle the balance between eventual and strong consistency to design an optimal data model for your application. In Google Cloud Datastore, the use of entity groups and ancestor queries is the best way to guarantee strong consistency over a scope of entities. If your application cannot incorporate entity groups because of the limitations described earlier, you may consider other options such as using keys-only queries or Memcache. For large applications, apply best practices such as the use of scattered IDs and reduced indexing to decrease the time required for consistency. It may also be important to combine Google Cloud Datastore with BigQuery to fulfill business requirements for complex queries and to reduce the usage of Google Cloud Datastore indexes as far as possible.</p>

  <h2><a name="h.ywh7cedcuhkk" id="h.ywh7cedcuhkk"></a>Additional Resources</h2>
  <p>The following resources provide more information about the topics discussed in this document:</p>

  <ul>
      <li><a href="https://developers.google.com/appengine/docs/python/datastore/">Google App Engine: Storing Data</a></li>
      <li><a href="https://developers.google.com/appengine/articles/datastore/overview">Mastering the Datastore (series)</a></li>
      <li><a href="http://googlecloudplatform.blogspot.com/">Google Cloud Platform Blog</a></li>
      <li><a href="https://developers.google.com/cloud-sql/">Google Cloud SQL</a></li>
      <li><a href="https://developers.google.com/appengine/training/cloud-sql/">Using Python App Engine with Google Cloud SQL</a></li>
      <li><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data</a></li>
      <li><a href="http://googleappengine.blogspot.com/2011/07/app-engine-152-sdk-released.html">App Engine 1.5.2 SDK Released</a></li>
      <li><a href="http://www.cidrdb.org/cidr2011/Papers/CIDR11_Paper32.pdf">Megastore: Providing Scalable, Highly Available Storage for Interactive Services</a></li>
  </ul>

  <br>
  <br>
  <hr>
  <p><a href="#ftnt_ref1" name="ftnt1" id="ftnt1">[1]</a> An entity group can even be formed by specifying only one key of the root or parent entity, without storing the actual entities for the root or parent, because the entity group functions are all implemented based on relationships between keys.
  </p>

  <p><a href="#ftnt_ref2" name="ftnt2" id="ftnt2">[2]</a> The supported limit is one update per second per entity group outside transactions, or one transaction per second per entity group. If you aggregate multiple updates into one transaction, then you are limited to a maximum transaction size of 10 MB and the maximum write rate of Datastore server.
  </p>


</div>
<!-- /maia-main -->
</div>
</div>
</div>


 <!-- is this feedback sticky needed?
  <div class="feedback-sticky"><a href="javascript:void(0);">Feedback</a></div>
  <script type="text/javascript" src="//www.gstatic.com/feedback/api.js"></script>
  <script>
    jQuery('body').delegate('.feedback-sticky', 'click', function() {
      _gaq.push(['_trackEvent', 'Feedback', 'User Feedback: ' + location.pathname]);
      userfeedback.api.startFeedback({'productId': '96209'});
    });
  </script>
  -->

  <!-- Scripts to include both on Goro + Devsite -->
  <script type="text/javascript">
   window.___gcfg = {
     lang: ''
   };
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
  </script>

  <!-- GTM implementation -->
  
  <!-- Start dataLayer -->
    <script>
      dataLayer = [{
        'country': '',
        'region': '',
        'language': 'en'
      }];
    </script>
  <!-- End dataLayer -->
  
  <!-- Start Google Tag Manager -->
  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5CVQBG"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5CVQBG');</script>
  <!-- End Google Tag Manager -->    



<!-- Global JS scripts to load; path will depend on whether we're on devsite or Goro -->
<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.2.15/angular.js"></script>
<script src="//ajax.googleapis.com/ajax/libs/angularjs/1.2.15/angular-sanitize.js"></script>

  <script src="/js/base.min.js"></script>




<!-- Secondary right-side scroll-nav -->
<script>
  new lfl.ui.ScrollNav({});
  new lfl.cloud.GlobalProductMenu();
</script>

<script>new cloud.SocialFeeds(document.getElementById('feeds'));</script>



  <div id="maia-signature"></div>
  <div id="maia-footer">

    <!-- maia-footer-local -->
    <div id="maia-footer-local">
      <div class="maia-aux">
        
          <div class="ent-footer-top">
  <div class="g-plus-wrapper">
    <div class="g-plusone" data-href="http://cloud.google.com"></div>
  </div>
  <div class="g-plus-link"><a href="https://plus.google.com/+googlecloudplatform" rel="publisher">Google+</a></div>
  <div class="search">
    <form onsumbit="return false;" class="maia-search">
    <input name="q" placeholder="Search this site" type="text">
    <input name="hl" type="hidden" value="">
    <input name="q" type="hidden" value="site:cloud.google.com/">
    <button class="maia-button" event="autotrack-data-g" data-g-event="Footer" data-g-action="Site Search" data-g-label="Submit">
      <span class="maia-search-icon">Search</span>
    </button>
    </form>
  </div>

</div>

<div class="ent-footer-links">
  <div class="ent-footer-unit">
    <h4><a href="/why-google/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Why Google">Why Google</a></h4>
    <ul>
      <li><a href="/why-google/#infrastructure" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Infrastructure">Infrastructure</a></li>
      <li><a href="/why-google/#product" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Product">Product</a></li>
      <li><a href="/why-google/#services" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Services">Services</a></li>
      <li><a href="/why-google/#scalability" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Scalability">Scalability</a></li>
      <li><a href="/why-google/#performance" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Performance">Performance</a></li>
      <li><a href="/why-google/#support" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Why Google" data-g-label="Support">Support</a></li>      
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/products/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Products">Products</a></h4>
    <ul>
      <li><a href="/products/app-engine/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="App Engine">App Engine</a></li>
      <li><a href="/products/compute-engine/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Compute Engine">Compute Engine</a></li>
      <li><a href="/products/cloud-storage/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud Storage">Cloud Storage</a></li>
      <li><a href="/products/cloud-sql/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud SQL">Cloud SQL</a></li>
      <li><a href="/products/cloud-datastore/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud Datastore">Cloud Datastore</a></li>
      <li><a href="/products/bigquery/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="BigQuery">BigQuery</a></li>
      <li><a href="/products/prediction-api/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Prediction API">Prediction API</a></li>
      <li><a href="/products/translate-api/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Translate API">Translate API</a></li>
      <li><a href="/products/cloud-endpoints/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Cloud Endpoints">Cloud Endpoints</a></li>
      <li><a href="/products/calculator/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Pricing Calculator">Pricing Calculator</a></li>
      <li><a href="/pricing/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Products" data-g-label="Pricing">Pricing</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/solutions" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Solutions">Solutions</a></h4>
    <ul>
      <li><a href="/solutions/mobile/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Mobile">Mobile</a></li>
      <li><a href="/solutions/gaming/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Gaming">Gaming</a></li>
      <li><a href="/solutions/hadoop/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="Hadoop">Hadoop</a></li>
      <li><a href="/solutions/mongodb/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Solutions" data-g-label="mongodb">mongodb</a></li>

    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/customers/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Customers" data-g-label="Customers">Customers</a></h4>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/developers/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Developers" data-g-label="Developers">Developers</a></h4>
    <ul>
      <li><a href="/developers#documentation" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Developers" data-g-label="Documentation">Documentation</a></li>
      <li><a href="/developers#resources" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Developers" data-g-label="Resources">Resources</a></li>
    </ul>
  </div>

  <div class="ent-footer-unit">
    <h4><a href="/support/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Support">Support</a></h4>
    <ul>
      <li><a href="https://support.google.com/" target="_blank" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Google Cloud Platform Support Help Center">Platform Support Help Center</a></li>
      <li><a href="https://support.google.com/cloudbilling/" target="_blank" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Google Cloud Billing Help Center">Billing Help Center</a></li>
      <li><a href="https://enterprise.google.com/supportcenter" target="_blank" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Support" data-g-label="Google Enterprise Support Center">Google Enterprise Support Center</a></li>      
    </ul>
    
  </div>

  
  <div class="ent-footer-unit">
    <h4><a href="/partners/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Partners" data-g-label="Partners">Partners</a></h4>
    <ul>
      <li><a href="/partners/technology-partners/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Partners" data-g-label="Find A Technology Partner">Technology Partners</a></li>
      <li><a href="/partners/service-partners/" event="autotrack-data-g" data-g-event="Footer" data-g-action="Footer Links: Partners" data-g-label="Find A Service Partner">Find a Service Partner</a></li>
    </ul>
  </div>
 
</div>
<br class="clear" />

        
      </div>
    </div>
    <!-- /maia-footer-local -->

    <!-- maia-footer-global -->
    <div id="maia-footer-global">
      <div class="maia-aux">
        <ul>
          <li><a href="http://www.google.com/">Google</a></li>
          <li><a href="https://developers.google.com/readme/terms">Terms of Service</a></li>
          <li><a href="http://www.google.com/intlprivacy/">Privacy Policy</a></li>
        </ul>
      </div>
    </div>
  </div>
  <!-- /maia-footer-global -->
  <script type="text/javascript" async="" defer="" src="//www.gstatic.com/feedback/api.js"></script>
  <script id="jqueryui" src="//ajax.googleapis.com/ajax/libs/jqueryui/1.8.10/jquery-ui.min.js"></script>

  <!--script src="/_static/js/script_foot.js"></script-->
  
  </body>
</html>
