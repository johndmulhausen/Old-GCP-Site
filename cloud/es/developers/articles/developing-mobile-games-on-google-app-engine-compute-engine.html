<!DOCTYPE html>
<html devsite="">
<head>
<title>Mobile Articles &amp; Mobile Development Guides — Google Cloud Platform</title>
<meta name="description" content="Read technical articles on mobile solutions with Google Cloud Platform. Mobile specific articles cover application development, mobile backend and mobile gaming.">
<meta name="hide_page_heading" value="true">
<meta name="full_width" value="true">
<meta name="top_category" value="developers">
<meta name="subcategory" value="articles">
<meta name="viewport" content="initial-scale=1, minimum-scale=1, width=device-width">
<link rel="apple-touch-icon" href="//cloud.google.com/_static/images/apple-touch-icon.png">
<link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,300,400,600,700" rel="stylesheet">
<link href="/cloud/css/default.css" rel="stylesheet"><!--[if lt IE 9]>
    <link rel="stylesheet" media="screen" href='/c/cp-ie.css'>
    <![endif]-->
<script src="/cloud/js/floodlight.js">
</script>
</head>
<body>
<div id="maia-main" class="cp-article">
<div class="maia-cols">
<div class="maia-col-9">
<div>
<div style="float:right">
<div class="g-plusone"></div>
</div>
<h1 class="title">Empresas que utilizan Google Cloud Platform</h1>
</div>
<div class="cp-article-tutorial">
<h1>Presentación</h1>
<p>El mercado de los juegos para móviles está creciendo rápidamente, y se espera que el negocio ascienda a unos 12.000 millones de euros para el año 2016.<sup><a href="#ftnt1" name="ftnt_ref1" id="ftnt_ref1">[1]</a></sup> En realidad, en el cuarto trimestre de 2012, el gasto mundial en juegos para las plataformas iOS de Apple y Android de Google superó el gasto en juegos para consolas portátiles.<sup><a href="#ftnt2" name="ftnt_ref2" id="ftnt_ref2">[2]</a></sup></p>
<p>Se está produciendo un cambio en el modelo de ingresos de juegos para móviles, que pasa de los juegos de pago a los juegos gratuitos en los que los ingresos se generan a partir de bienes virtuales y de otras compras dentro del juego, así como de la publicidad dentro del juego. Con estas nuevas tendencias, es necesario que los juegos para móviles sean más atractivos y envolventes.</p>
<p>Estos juegos no solo exigen que las experiencias de usuario sean atractivas en el cliente, sino que también hacen necesario que haya servicios backend elaborados y escalables. Google Cloud Platform te permite crear fácilmente el backend del juego para móviles, tal como se presenta en este artículo de soluciones.</p>
<h2>Ámbito</h2>
<p>Este documento está dirigido a arquitectos y a desarrolladores que tengan interés en crear sus propios backends de juegos para móviles y en diseñar los patrones de interacción entre los clientes móviles y el backend.</p>
<p>La metodología y la arquitectura que se presentan en este documento se pueden aplicar al desarrollo de un nuevo juego para móviles estándar. Sin embargo, hay dos opciones más que pueden ser pertinentes en función de tu situación y de tus necesidades. La primera es <a href="https://developers.google.com/cloud/samples/mbs/">Mobile Backend Starter</a>, que puede ser una opción si prefieres ponerte en marcha <a href="https://developers.google.com/cloud/samples/mbs/"></a>sin tener que programar tu propio backend personalizado de juegos para móviles. La segunda es la arquitectura de la <a href="https://cloud.google.com/resources/articles/dedicated-server-gaming-solution">Solución de juegos en servidor dedicado</a>, que puede ser una opción si tu juego para móviles hace necesario el uso de servidores para juegos dedicados.</p>
<p>En este documento se describe cómo desarrollar nuevos juegos para móviles de alta escalabilidad en Google Cloud Platform. Se aplica la arquitectura de referencia de soluciones para móviles publicada <a href="https://cloud.google.com/resources/articles/mobile-application-solutions.html">en esta página</a> a la vez que se proporcionan más detalles y ejemplos específicos para la creación de juegos para móviles. Este artículo va acompañado de una aplicación de juego para móviles de ejemplo con el código fuente completo.</p>
<p>La creación de la parte cliente de los juegos para móviles no se abarca en este documento. Sin embargo, sí se incluye información básica pertinente para comunicarse con el backend de juegos para móviles, para autenticar usuarios y para enviar notificaciones push.</p>
<h2>Requisitos</h2>
<p>Entre los requisitos habituales de los juegos para móviles atractivos se incluyen los siguientes:</p>
<ol>
<li>Funciones del juego:
<ul>
<li>contenido de juego dinámico,</li>
<li>datos de juego almacenados fuera de los dispositivos,</li>
<li>marcador,</li>
<li>modo multijugador,</li>
<li>emparejamiento de jugadores,</li>
<li>generación de tableros de juego,</li>
<li>robots del sitio del servidor.</li>
</ul>
</li>
<li>Funciones de la plataforma:
<ul>
<li>compatibilidad con dispositivos iOS y Android a través de aplicaciones cliente nativas,</li>
<li>notificaciones push para dispositivos iOS y Android,</li>
<li>autenticación de usuarios,</li>
<li>alta escalabilidad.</li>
</ul>
</li>
<li>Funciones para empresas:
<ul>
<li>compras dentro del juego,</li>
<li>análisis del juego.</li>
</ul>
</li>
</ol>
<p>La creación de tu juego para móviles en Google Cloud Platform puede ayudarte a cumplir estos requisitos.</p>
<h1>Arquitectura de las soluciones de juegos para móviles</h1>
<p>En el diagrama siguiente (figura 1) se muestra la arquitectura de nivel alto para los juegos para móviles en Google Cloud Platform:</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/architecture-diag.jpg" alt="">
<figcaption>Figura 1. Diagrama de la arquitectura de la solución de juegos para móviles</figcaption>
</figure>
<h3>Información general de nivel alto</h3>
<p>Estos son los componentes clave de la arquitectura de la solución propuesta:</p>
<ul>
<li>el cliente de tu juego para móviles: cualquier combinación de aplicaciones Android, iOS y HTML/JavaScript,</li>
<li>la aplicación backend de tu juego para móviles,</li>
<li>la capa de comunicación entre los clientes de tu juego para móviles y tu backend&nbsp;móvil,</li>
<li>varios servicios en la nube para almacenar los datos y las imágenes del juego, para entregar las notificaciones push, etc.</li>
</ul>
<h3>Funciones de los componentes clave</h3>
<p>Una de las opciones de diseño es determinar qué funciones del juego para móviles se asignarán a cada componente de la solución. En concreto, qué funciones se implementarán en la aplicación cliente, qué funciones implementará el backend de juegos para móviles y cuáles proporcionarán los servicios en la nube.</p>
<p>Ahora que la potencia de los smartphones y los tablets es cada vez mayor, es práctico implementar tantas funciones como sea posible en los clientes de juego. La función principal del backend del juego para móviles es enriquecer la experiencia en general, hacer que el juego sea más atractivo y envolvente, y ofrecer funciones que no serían posibles solo con una aplicación cliente.</p>
<p>Muchos juegos para móviles de gran popularidad utilizan backends móviles para:</p>
<ul>
<li>ofrecer contenido de juego dinámico,</li>
<li>proporcionar partidas multijugador, incluido el emparejamiento de jugadores,</li>
<li>almacenar datos fuera del dispositivo móvil, por ejemplo, el último nivel completado o las puntuaciones obtenidas en las partidas anteriores,</li>
<li>administrar el marcador,</li>
<li>administrar las notificaciones push,</li>
<li>ofrecer compras dentro del juego,</li>
<li>proporcionar análisis del juego.</li>
</ul>
<h3>Backend de tu juego para móviles<sup><a href="#ftnt3" name="ftnt_ref3" id="ftnt_ref3">[3]</a></sup> en la nube</h3>
<p>Si utilizas Google Cloud Platform para crear tu juego para móviles, puedes ejecutar el backend de tu juego en Google App Engine, una plataforma que usan <a href="https://cloud.google.com/solutions/gaming">muchos juegos online de éxito</a> desarrollados por <a href="https://cloud.google.com/customers/#cp-mobile">empresas pequeñas y grandes</a>. Te ofrece las ventajas siguientes de la infraestructura de Google:</p>
<ul>
<li><a href="https://developers.google.com/appengine/whyappengine#scale">escalabilidad</a> <a href="https://developers.google.com/appengine/whyappengine#scale">automática</a>,</li>
<li><a href="https://developers.google.com/appengine/docs/whatisgoogleappengine#The_Application_Environment">equilibrio de carga automático entre las instancias del backend móvil,</a></li>
<li><a href="https://developers.google.com/appengine/docs/java/config/appconfig#Static_Files_and_Resource_Files">publicación y almacenamiento en la memoria caché de contenido estático,</a></li>
<li><a href="http://developers.google.com/appengine/whyappengine#reliable">funciones de fiabilidad, rendimiento y seguridad,</a></li>
<li><a href="http://developers.google.com/appengine/docs/adminconsole/index">supervisión y administración,</a></li>
<li><a href="https://developers.google.com/appengine/docs/java/config/dos?hl=en">protección DoS configurable,</a></li>
<li><a href="https://developers.google.com/appengine/docs/python/endpoints/auth">integración con Cuentas de Google para la autenticación OAuth2 (tanto para clientes Android como iOS</a>).</li>
</ul>
<h1>Desarrollo de un juego para móviles en Google Cloud Platform</h1>
<h2>Situación de juego de ejemplo</h2>
<p>La arquitectura que se describe en este documento se puede aplicar a muchos juegos para móviles. Se utiliza la situación de ejemplo siguiente para, sobre todo, hacer que el diseño sea más específico. La mayoría de las opciones de diseño que se tratan también son pertinentes para otros juegos para móviles.</p>
<h3>Griddler: juego para móviles multijugador sobre acertijos</h3>
<p>Imagina que quieres crear un juego para móviles multijugador sobre conocimientos o sobre acertijos llamado Griddler. Habrá dos o más jugadores que competirán para resolver tantos acertijos como puedan dentro de un límite de tiempo específico. Esta competición se llamará "partida". A cada jugador de una partida se le muestra la misma cuadrícula de letras, como la del siguiente ejemplo:</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/griddler.png" height="195" width="196" alt="">
<figcaption>Figura 2. Captura de pantalla de Griddler</figcaption>
</figure>
<p>Cada jugador deberá enfrentarse a la misma serie de acertijos en cada cuadrícula. Por ejemplo, un primer acertijo podría ser:</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/sample-q.png" height="396" width="222" alt="">
<figcaption>Figura 3. Ejemplo de pregunta en Griddler</figcaption>
</figure>
<p>Cada jugador tiene que averiguar la respuesta y luego hacer un gesto táctil para marcar la palabra correcta con las letras contiguas de la cuadrícula, tal como se muestra en la figura 4.</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/answ-entry-griddler.png" height="396" width="222" alt="">
<figcaption>Figura 4. Respuesta marcada en Griddler</figcaption>
</figure>
<p>Cuando un jugador encuentra la palabra correcta o decide saltarse un acertijo concreto, se le muestra otro acertijo para la misma cuadrícula, como se muestra en la figura 5.</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/riddle-griddler.png" height="396" width="222" alt="">
<figcaption>Figura 5. Otro acertijo de ejemplo en Griddler</figcaption>
</figure>
<p>Los clientes del juego obtienen la definición de tablero del backend de juegos para móviles al inicio de cada partida. De este modo, se pueden añadir tableros y acertijos nuevos sin necesidad de actualizar las aplicaciones cliente. La secuencia de acertijos para un tablero determinado puede ser aleatoria o fija. La definición de tablero obtenida incluye los acertijos de ese tablero junto con la asignación de tiempo para una partida determinada. Cuando se agota el tiempo asignado, gana el jugador que haya resulto más acertijos. Si empatan, gana la ronda el jugador que haya resuelto antes los acertijos.</p>
<p>En cualquier momento dado, puede haber millones de partidas en curso, cada una con entre 1 y N jugadores. Además, Griddler tiene un modo de jugador único que se puede utilizar para practicar la mecánica del juego o simplemente para resolver acertijos por diversión.</p>
<p>Además de proporcionar definiciones de tablero para los clientes, el backend de juegos para móviles también tiene las responsabilidades siguientes:</p>
<ul>
<li>administrar la lista de jugadores y sus estadísticas (por ejemplo, cuántas partidas ha jugado un determinado jugador en diferentes dispositivos o cuántas partidas multijugador ha ganado),</li>
<li>administrar la lista de dispositivos que los jugadores han utilizado para poder enviar notificaciones push a esos dispositivos,</li>
<li>enviar invitaciones de juego para partidas multijugador,</li>
<li>retransmitir las aceptaciones, rechazos y cancelaciones de invitaciones.</li>
</ul>
<h2>Componentes clave de las soluciones de juegos para móviles</h2>
<p>La arquitectura que se describe en este documento te permite implementar fácilmente Griddler y otros juegos para móviles. Los clientes se pueden implementar como aplicaciones Android e iOS nativas. El backend de juegos para móviles se puede ejecutar en Google App Engine. Se puede utilizar Google Cloud Endpoints para mostrar la API del backend móvil y utilizarla desde los clientes.</p>
<h3>Aplicaciones cliente de juegos para móviles</h3>
<p>Las aplicaciones cliente de Android y de iOS se encargan de toda la interfaz de usuario y de las interacciones del usuario con el juego, así como de la mecánica del juego. El diseño de estas funciones no es muy diferente al diseño de un juego para móviles que no use un backend de juegos para móviles y, por lo tanto, queda fuera del ámbito de este documento.</p>
<p>La diferencia es que los clientes Griddler funcionan gracias a un backend de juegos para móviles. El cliente se comunica con el backend para ofrecer las partidas multijugador y el emparejamiento de jugadores. Dentro de estas funciones se incluye la gestión de las notificaciones push recibidas con invitaciones de juego enviadas por el backend. El backend también proporciona al cliente cualquier contenido de juego dinámico, como por ejemplo una definición de tablero para un juego determinado. Esto incluye la cuadrícula de letras y todos los acertijos de una cuadrícula determinada, así como las respuestas válidas para esos acertijos.</p>
<p>Una vez iniciada una partida, ya sea de un solo jugador o multijugador, el cliente no se tiene que comunicar con el backend hasta que la partida termina. A continuación, el cliente envía los resultados de la partida al backend de juegos para móviles y el backend los almacena y determina quién ha ganado la partida multijugador.</p>
<h3>Backend de juegos para móviles</h3>
<p>El backend de juegos para móviles tiene que mostrar la API adecuada para que el cliente habilite la mecánica de juego y la experiencia de usuario que quiera.</p>
<p>La API de Griddler incluye métodos para:</p>
<ul>
<li>la administración del juego, por ejemplo, startNewSinglePlayerGame (que, entre otras cosas, obtiene una definición del tablero) y gameFinished,</li>
<li>las invitaciones de jugadores, por ejemplo, sendInvitation, acceptInvitation, etc.,</li>
<li>las notificaciones, por ejemplo, registerDeviceForPushNotification.</li>
</ul>
<p>Estos métodos se pueden mostrar a los clientes según lo descrito en la <a href="#cbym">siguiente sección</a>.</p>
<p>Al gestionar solicitudes de API síncronas, el backend móvil <a href="#storedata">almacena, obtiene y administra los datos en un almacén persistente</a> y, para los datos usados a menudo como, por ejemplo, las definiciones de tablero, también utiliza el <a href="#odawm">almacenamiento en la memoria caché</a>.</p>
<p>Aparte de gestionar las solicitudes del cliente, el backend móvil se encarga del <a href="#odawm">procesamiento asíncrono</a> necesario para el juego para móviles, de la <a href="#pushnotifications">administración de notificaciones push</a>, de la gestión de las <a href="#scheduled">tareas programadas</a>, etc.</p>
<a name="cbym" id="cbym"></a>
<h3>Comunicación entre los clientes del juego para móviles y el backend del juego para móviles</h3>
<p>Tal como se analiza en el <a href="https://cloud.google.com/resources/articles/mobile-application-solutions">artículo sobre soluciones para móviles</a>, la forma recomendada de mostrar la API desde el backend móvil y de utilizarla desde el cliente móvil es usar <a href="https://developers.google.com/appengine/docs/java/endpoints/overview">Google Cloud Endpoints</a>.<sup><a href="#ftnt4" name="ftnt_ref4" id="ftnt_ref4">[4]</a></sup> Esta tecnología te permite definir la API a través de anotaciones directas en el código fuente. Además, te permite utilizar herramientas para generar bibliotecas cliente de Android y de iOS de escritura fiable, así como el código JavaScript para interaccionar con la API desde clientes web. También proporciona compatibilidad con la autenticación basada en OAuth2 con cuentas de Google, de modo que el código del backend de tu juego para móviles pueda averiguar la identidad del jugador.</p>
<p>Por ejemplo, en Griddler, el método para enviar una invitación se declara de la siguiente manera:</p>
<pre>
@ApiMethod(httpMethod = "PUT", path ="game/{gameId}/invitation/{playerId}")
public InvitationResult sendInvitation(@Named("gameId") Long gameId,
 @Named("playerId") Long playerId, User user) throws ServiceException { }
</pre>
<p>El código anterior declara la API sendInvitation, que estará representada como una solicitud PUT HTTP con la URL especificada en el argumento de ruta. Los argumentos gameId y playerId los transferirá el cliente de manera explícita. La infraestructura de Google Cloud Endpoints rellenará el objeto de usuario en función de la información de autenticación que el cliente proporcione de manera implícita. Si quieres obtener más información sobre la anotación @Api, puedes consultar la <a href="https://developers.google.com/appengine/docs/java/endpoints/annotations"></a><a href="https://developers.google.com/appengine/docs/java/endpoints/annotations">documentación</a> de Cloud Endpoints.</p>
<p>Si se utilizan las herramientas de Cloud Endpoints para generar bibliotecas cliente, el cliente de Android puede invocar esta API mostrada desde el backend móvil. Solo hay que realizar la siguiente llamada:</p>
<pre>
InvitationResult invitationResult = gameBackend.sendInvitation(
gameId, playerId)).execute();
</pre>
<p>Esta llamada se debe ejecutar de forma asíncrona para evitar que se bloqueen las llamadas de red en el proceso de la IU.</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/communication.png" height="341" width="579" alt="">
<figcaption>Figura 6. La comunicación entre el cliente del juego para móviles y el backend del juego</figcaption>
</figure>
<a name="storedata" id="storedata"></a>
<h3>Almacenamiento de datos<sup><a href="#ftnt5" name="ftnt_ref5" id="ftnt_ref5">[5]</a></sup></h3>
<p>Los juegos para móviles que son atractivos y envolventes suelen necesitar almacenar datos fuera de los dispositivos cliente.</p>
<p>Es posible que algunos juegos para móviles quieran usar contenido dinámico representado como objetos grandes y generalmente binarios. Esto incluye las imágenes que definen partes de un mundo de juego virtual o avatares que los jugadores suben. Para este tipo de datos, puedes usar <a href="http://developers.google.com/storage/docs/getting-started">Google Cloud Storage</a>, un servicio que permite almacenar objetos y archivos con tamaños que pueden ascender a terabytes. Consulta también la sección <a href="#sapi">Publicación y procesamiento de imágenes</a> que hay más adelante.</p>
<p>El resto de tipos de datos que se tienen que almacenar fuera de los dispositivos cliente son propiedades y entidades más concretas. Estas propiedades y entidades pueden incluir información sobre el nivel más alto que se ha completado en un juego para móviles y otros datos sobre jugadores, como por ejemplo sus apodos, el registro de los dispositivos de los jugadores para las notificaciones push, los registros de sus compras dentro del juego y otros datos específicos del juego.</p>
<p>Las propiedades de estas entidades también pueden incluir una referencia a objetos almacenados en Google Cloud Storage, como por ejemplo el nombre del objeto y, opcionalmente, un nombre de segmento o una URL.</p>
<p>Con el backend móvil alojado en Google App Engine, el lugar recomendado para almacenar esas entidades es <a href="https://developers.google.com/datastore/">Cloud Datastore</a>. Proporciona un almacenamiento de datos de objetos NoSQL,<sup><a href="#ftnt6" name="ftnt_ref6" id="ftnt_ref6">[6]</a></sup> sin esquema y altamente escalable, con un motor de consulta y transacciones atómicas.</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/storing-data.jpg" height="350" width="305" alt="">
<figcaption>Figura 7. Almacenamiento de datos</figcaption>
</figure>
<p>Por ejemplo, en Griddler, las entidades clave son:</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/key-entities.jpg" alt="">
<figcaption>Figura 8. Entidades clave usadas en Griddler</figcaption>
</figure>
<ul>
<li>Jugador</li>
<li>Tablero: una definición de una cuadrícula de juego y los acertijos de esa cuadrícula.</li>
<li>Partida: una instancia de uno o más jugadores que compiten para resolver acertijos en un tablero determinado.</li>
<li>Invitación: una entidad utilizada para iniciar las partidas multijugador.</li>
<li>Jugabilidad: una entidad que representa el estado y los resultados de una partida a la que un jugador está jugando. En el caso de las partidas multijugador, habrá muchas entidades de jugabilidad para una partida determinada (una por jugador).</li>
<li>Dispositivo: información específica de la plataforma que se necesita para enviar notificaciones push a un dispositivo determinado (por ejemplo, token de dispositivo para iOS e identificador de registro GCM para Android).</li>
</ul>
<p>Para posibilitar la coherencia, la invitación y la jugabilidad pertenecen al <a href="https://developers.google.com/appengine/docs/java/gettingstarted/usingdatastore?hl=en">grupo de entidades</a> con origen en la entidad antecedente de partida. Del mismo modo, la entidad de dispositivo pertenece al grupo de entidades con origen en la entidad antecedente de jugador.</p>
<p>Si utilizas el almacén de datos para almacenar las entidades, tus juegos para móviles se pueden escalar fácilmente a millones de jugadores.</p>
<p>Puesto que Griddler no utiliza datos binarios ni grandes en la implementación actual, almacena todos sus datos en el almacén de datos. Sin embargo, si se aplican mejoras para proporcionar pistas visuales para los acertijos o para permitir a los jugadores subir sus avatares, Griddler podría utilizar Google Cloud Storage para almacenar imágenes.</p>
<a name="odawm" id="odawm"></a>
<h3>Optimización del acceso a los datos con Memcache</h3>
<p>Cuando la carga aumenta, el backend de tu juego para móviles puede estar formado por miles de instancias individuales que gestionan solicitudes. Si los clientes de tu juego para móviles hacen solicitudes frecuentes al backend para obtener los mismos datos, el acceso a los datos se puede optimizar para evitar obtener los datos desde el almacenamiento persistente para cada solicitud.</p>
<p>Un backend que se ejecute en Google App Engine puede utilizar un servicio de almacenamiento en memoria caché de datos distribuido llamado <a href="http://developers.google.com/appengine/docs/java/memcache/">Memcache</a> para almacenar y obtener los datos a los que se acceda a menudo (figura 9). Si utilizas Memcache, no solo permites que el backend de tu juego para móviles tenga un mejor rendimiento y una mejor escalabilidad, sino que también se reduce el coste de acceder al almacén de datos de App Engine, ya que la aplicación enviará menos solicitudes al almacén de datos de App Engine.</p>
<p>Por ejemplo, puede que haya millones de jugadores que jueguen a Griddler a la vez y es posible que haya hasta cientos de miles de jugadores que estén resolviendo acertijos del mismo tablero (cuadrícula de letras) a la vez. En vez de obtener las definiciones de tablero cada vez, tiene sentido almacenarlas en la memoria caché.</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/optimizing-data.jpg" height="421" width="352" alt="">
<figcaption>Figura 9. Optimización del acceso a los datos con Memcache</figcaption>
</figure>
<h3>Procesamiento asíncrono con colas de tareas</h3>
<p>A veces no se puede, ni conviene, hacer todo el trabajo asociado a una solicitud recibida de un cliente de juego para móviles antes de que se tenga que enviar la respuesta al dispositivo del usuario.</p>
<p>Por ejemplo, para que un juego sea más atractivo y esté más relacionado con las redes sociales, Griddler podría tener una función para notificar a los amigos del jugador que el jugador ha alcanzado una puntuación muy alta y ha logrado entrar en el marcador. Esto se podría activar cuando el cliente llame a la API gameFinished, pero es importante tener en cuenta que un jugador puede tener muchos amigos y que el cliente no se debe bloquear hasta que se notifique a todos los amigos. Un diseño síncrono de estas características no solo bloquearía el cliente, sino que también sería poco fiable. En su lugar, como parte de la API gameFinished, el backend del juego para móviles puede almacenar los resultados del juego, registrar la necesidad de procesar las notificaciones y enviar de inmediato la respuesta al cliente sin tener que esperar a que se procesen todas las notificaciones.</p>
<p>El código que se ejecuta en Google App Engine puede utilizar un servicio llamado <a href="http://developers.google.com/appengine/docs/java/taskqueue/">colas de tareas</a> para poner en cola información sobre el trabajo (las tareas) que hay que hacer de forma asíncrona. En el ejemplo tratado anteriormente, tu aplicación podría poner en cola una tarea para notificar a los amigos de los jugadores que el jugador se ha clasificado entre los 20 primeros jugadores.</p>
<p>Normalmente, tendrías que configurar el servicio de cola de tareas para que enviara las tareas en cola (<a href="http://developers.google.com/appengine/docs/java/taskqueue/overview-push">modelo push</a>) a tu código que está en ejecución en Google App Engine como solicitudes HTTP a una URL seleccionada. El backend de tu juego para móviles puede procesar estas solicitudes a través de controladores de solicitudes web normales. En el ejemplo anterior, el controlador de solicitudes fue capaz de obtener la información de la tarea de la solicitud HTTP, de buscar los amigos del jugador y de luego notificar a cada uno de ellos, ya fuera mediante la creación de entradas en una red social en nombre del jugador o mediante el envío de notificaciones push tal como se describe <a href="#pushnotifications">más adelante</a>.</p>
<p>De forma alternativa, el código del backend móvil puede <a href="http://developers.google.com/appengine/docs/java/taskqueue/overview-pull">retirar las</a> <a href="http://developers.google.com/appengine/docs/java/taskqueue/overview-pull">tareas</a> de las colas. Esto puede ser útil, por ejemplo, si quieres controlar de modo explícito el procesamiento de tareas. Otra situación en la que la retirada de tareas puede ser útil es si quieres procesar las tareas fuera de App Engine, por ejemplo, con instancias de Google Compute Engine, tal como se describe en el <a href="https://cloud.google.com/resources/articles/mobile-application-solutions">artículo sobre</a> <a href="https://cloud.google.com/resources/articles/mobile-application-solutions">soluciones</a> <a href="https://cloud.google.com/resources/articles/mobile-application-solutions">para móviles</a>.</p>
<a name="pushnotifications" id="pushnotifications"></a>
<h3>Notificaciones push</h3>
<p>Las notificaciones push permiten que los backends del juego notifiquen a los clientes si hay cambios de estado u otra información pertinente sin que los clientes tengan que realizar solicitudes constantes. Las notificaciones push se pueden utilizar para crear una experiencia de usuario completa a la vez que se optimiza el uso de batería y de ancho de banda. En función de la plataforma cliente, tu juego para móviles puede usar esta tecnología para mostrar <a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html">mensajes automático</a><a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html">s</a> y otras notificaciones en los dispositivos de los usuarios aunque el cliente del juego para móviles no esté en ejecución. También se puede utilizar para seguir transmitiendo los datos pertinentes al cliente del juego para móviles.</p>
<p>En Griddler, las notificaciones push se utilizan para enviar las invitaciones cuando un jugador quiere retar a un amigo. Con las notificaciones push se puede invitar a amigos que no tengan el juego en ejecución en sus dispositivos.</p>
<p>Con el código del backend de tu juego para móviles en ejecución en Google App Engine, puedes organizar el envío de notificaciones push a los usuarios gracias a las siguientes características tecnológicas que se te brindan:</p>
<ul>
<li><a href="http://developer.android.com/google/gcm/index.html">Mensajería en la nube de Google</a> para Android (GCM): un servicio de Google que te permite enviar datos a los usuarios que tengan instalada tu aplicación cliente de juego para móviles en sus dispositivos con tecnología Android. Si utilizas Eclipse, puedes hacer que el <a href="http://developers.google.com/eclipse/">complemento de Google para Eclipse</a> genere código básico.</li>
<li>API de sockets<sup><a href="#ftnt7" name="ftnt_ref7" id="ftnt_ref7">[7]</a></sup> para enviar notificaciones push con el servicio de notificaciones push de Apple® a los usuarios de iOS. Para empezar, puedes leer un artículo de soluciones sobre cómo <a href="https://cloud.google.com/resources/articles/ios-push-notifications">organizar las notificaciones push de iOS en Google Cloud Platform</a> y revisar el <a href="https://github.com/GoogleCloudPlatform/solutions-ios-push-notification-sample-backend-java">código de ejemplo publicado en Github</a>.</li>
</ul>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/push-notification.png" height="438" width="457" alt="">
<figcaption>Figura 10. Notificación push</figcaption>
</figure>
<a name="sapi" id="sapi"></a>
<h3>Publicación y procesamiento de imágenes</h3>
<p>Algunas imágenes estáticas, como por ejemplo varios iconos que formen parte de tu juego y que se utilicen para crear la interfaz de usuario de tu aplicación cliente, se pueden empaquetar (a menudo en varias resoluciones) en tus clientes nativos de juegos para Android y para iOS. Sin embargo, así aumenta el tamaño del paquete y, si es grande, puede disuadir a los usuarios de descargar tu aplicación o puede aumentar las probabilidades de que la desinstalen cuando se queden sin espacio en el dispositivo.</p>
<p>A menudo, no es práctico ni posible incluir en el paquete de la aplicación cliente todas las imágenes que un juego necesita. Por ejemplo, tu juego para móviles podría tener mundos virtuales grandes o dinámicos con gráficos elaborados que se representen como imágenes con un tamaño total de cientos de megabytes o gigabytes. Aunque el tamaño de las imágenes no sea tan grande, es conveniente que puedas añadir nuevos gráficos al juego sin forzar a los usuarios a actualizar sus aplicaciones cliente.</p>
<p>Por ejemplo, Griddler podría ampliarse para incluir alguna pista visual para un acertijo concreto. También podría permitir a los jugadores subir imágenes que representen sus avatares.</p>
<p>Si puedes preparar este tipo de imágenes en resoluciones y en formatos optimizados para tus clientes de juegos para móviles, puedes subirlas a <a href="http://developers.google.com/storage/docs/getting-started">Google Cloud Storage</a> y proporcionar a los clientes móviles URL directas a estas imágenes. Este método permite una fácil escalabilidad, ya que permite a los clientes móviles recuperar estas imágenes directamente desde el almacenamiento en la nube escalable y sin que tu código del backend móvil tenga que participar.</p>
<p>En algunos casos, te puede interesar manipular y procesar las imágenes además de almacenarlas. Por ejemplo, puede que quieras publicar las imágenes en tamaños ajustados de manera dinámica en función de la resolución de los dispositivos cliente. En tales situaciones, puedes utilizar el <a href="https://developers.google.com/appengine/docs/java/images/">servicio de imágenes</a> de Google App Engine para modificar el tamaño de las imágenes, para girarlas, para darles la vuelta y para recortarlas, así como para mejorar las fotografías con un algoritmo predefinido. Estas acciones se pueden realizar en imágenes de Google Cloud Storage y de otras fuentes. A continuación, las imágenes modificadas se pueden publicar para los clientes directamente desde la infraestructura de publicación de imágenes dinámica que Google proporciona sin que el código del backend de tu juego para móviles se vea implicado. Tu código solo se encarga del uso de la API del servicio de imágenes para obtener la URL de imagen correcta y de proporcionar esta URL a los clientes de juegos para móviles.</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/serving-processing-imgs.jpg" height="373" width="467" alt="">
<figcaption>Figura 11. Publicación y procesamiento de imágenes</figcaption>
</figure>
<a name="scheduled" id="scheduled"></a>
<h3>Tareas programadas</h3>
<p>Además de procesar solicitudes de los clientes de juegos para móviles de manera síncrona a través de Google Cloud Endpoints y de manera asíncrona mediante colas de tareas, puede que el código del backend de tu juego para móviles tenga que hacer algún tipo de procesamiento en varios intervalos periódicos o semiperiódicos. Por ejemplo, si quieres que el backend de tu juego para móviles envíe notificaciones push a los jugadores que no hayan jugado a tu juego durante una cantidad de días y animarles a volver a jugar, y si quieres que este procesamiento se haga en momentos específicos del día.</p>
<p>También puede ser buena idea que el backend de tu juego para móviles actualice algunos datos almacenados en memoria caché en Memcache cada cinco minutos o que actualice las estadísticas de los mejores jugadores cada 15 minutos.</p>
<p>Si el código del backend de tu juego para móviles se ejecuta en Google App Engine, la configuración de este tipo de tareas programadas es sencilla con el <a href="http://developers.google.com/appengine/docs/java/config/cron">servicio cron</a>. Puedes configurarlo para invocar algunas URL en tu backend móvil en los intervalos solicitados o a horas específicas.</p>
<figure><img src="/cloud/images/articles/developing-mobile-games-on-gcp/scheduled-jobs.jpg" height="282" width="412" alt="">
<figcaption>Figura 12. Tareas programadas con el servicio cron</figcaption>
</figure>
<h2>Servicios de Google Play Games</h2>
<p>Una manera fácil de hacer que tus juegos Android, iOS y web estén más relacionados con las redes sociales es usar los <a href="https://developers.google.com/games/services/">servicios de Google Play Games</a>. Estos servicios te permiten recompensar a los jugadores con logros, atraer la participación con marcadores y permitir que compitan varios jugadores o que cooperen entre ellos para hacer que el juego sea más dinámico.</p>
<h2>Aplicaciones de ejemplo</h2>
<p>Griddler, la aplicación de ejemplo, se puede descargar de <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-backend-java">Github</a>. El backend móvil se implementa en Java y muestra la API REST mediante Cloud Endpoints. Almacena datos en el almacén de datos mediante una API de nivel bajo y envía notificaciones push. Los clientes de juegos <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-android-client">Android</a> y <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-iOS-client">iOS</a> se implementan como aplicaciones nativas. La comunicación entre los clientes y el backend de juegos para móviles se autentica mediante OAuth y mediante Cuentas de Google.</p>
<p>También puedes descargar <a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-backend-java">Cloud Adventure</a>, otro ejemplo de juego para móviles creado con una arquitectura similar. Cloud Adventure es un <a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-android-client">juego para Android</a> basado en texto que muestra algunos escenarios interesantes, como una sala de juego para varios jugadores y la selección de un apodo único. También muestra cómo utilizar una combinación de la mensajería en la nube de Google para Android y Cloud Endpoints para gestionar la finalización de un juego y el recuento de los resultados.</p>
<h2>Pasos siguientes</h2>
<p>Si aún no has visitado el portal de <a href="https://cloud.google.com/">Google Cloud Platform</a>, accede y haz clic en el enlace "Probar ahora". Se te indicará cómo seguir los pasos necesarios para crear un proyecto gratuito de Google Cloud, que después puedes utilizar para <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-backend-java">implementar</a> Griddler, el juego de ejemplo. A continuación, puedes jugar a este ejemplo, explorarlo e intentar ampliarlo; por ejemplo, puedes intentar añadir una pista visual a cada acertijo.</p>
<h2>Conclusión</h2>
<p>Al aprovechar Google Cloud Platform, puedes crear fácilmente un backend móvil para tus juegos. Puedes centrarte en el desarrollo del juego sin tener que preocuparte de implementar la infraestructura de TI, de hacer su mantenimiento ni de solucionar sus problemas. Puedes crear juegos para móviles absorbentes, atractivos y envolventes que se pueden escalar sin problemas para pasar de unos pocos usuarios a millones de jugadores de todo el mundo.</p>
<p>Ya hay muchos <a href="https://cloud.google.com/solutions/gaming">juegos de gran éxito</a> creados con tecnología de Google Cloud Platform y estamos deseando que nos cuentes tus logros.</p>
<br>
<hr>
<p><a href="#ftnt_ref1" name="ftnt1" id="ftnt1">[1]</a> Consulta <a href="http://www.abiresearch.com/press/mobile-gaming-revenues-will-exceed-16-billion-in-2">http://www.abiresearch.com/press/mobile-gaming-revenues-will-exceed-16-billion-in-2</a>.</p>
<p><a href="#ftnt_ref2" name="ftnt2" id="ftnt2">[2]</a> Consulta <a href="http://blog.appannie.com/app-annie-idc-portable-gaming-report/#ixzz2MczOY0l8">http://blog.appannie.com/app-annie-idc-portable-gaming-report/#ixzz2MczOY0l8</a>.</p>
<p><a href="#ftnt_ref3" name="ftnt3" id="ftnt3">[3]</a> En términos generales, en este documento, "backend" significa la parte de una solución para móviles que se ejecuta fuera de los dispositivos cliente. No se debe confundir con las <a href="http://developers.google.com/appengine/docs/java/backends/overview?hl=en">copias de servidor</a> de Google App Engine.</p>
<p><a href="#ftnt_ref4" name="ftnt4" id="ftnt4">[4]</a> Desde junio de 2013, Google Cloud Endpoints es una función experimental.</p>
<p><a href="#ftnt_ref5" name="ftnt5" id="ftnt5">[5]</a> En el apartado 4.2 de las <a href="https://developers.google.com/appengine/terms">Condiciones de servicio de Google App Engine</a> se describe tu obligación de proteger la privacidad y los derechos legales de tus Usuarios finales, inclusive la necesidad de proporcionar una política de privacidad que se adecue a la ley en lo referente al uso de los datos que recopiles y de obtener todos los consentimientos necesarios por parte de los usuarios finales para la recopilación, para el uso, para la supervisión o para la revelación de dichos datos.</p>
<p><a href="#ftnt_ref6" name="ftnt6" id="ftnt6">[6]</a> Si prefieres utilizar una base de datos SQL relacional, puedes usar <a href="http://developers.google.com/cloud-sql/">Google Cloud SQL</a> <a href="http://developers.google.com/cloud-sql/faq#choice">en vez del almacén de datos o de forma complementaria</a>.</p>
<p><a href="#ftnt_ref7" name="ftnt7" id="ftnt7">[7]</a> Desde junio de 2013, la API de sockets es una función experimental.</p>
</div>
<!-- /maia-main --></div>
<div class="maia-col-3"><br>
<img src="//www.google.com/images/icons/product/feedback-16.png" class="g-app-icon" alt=""> <a href="javascript:void(0);" class="google-feedback">Comentarios sobre este documento</a><br>
<br>
<hr>
<h4>Aplicaciones de ejemplo</h4>
<ul>
<li>Griddler, juego para móviles multijugador<br>
<a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-backend-java" target="popout">[Backend Java]</a> <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-android-client" target="popout">[Cliente Android]</a> <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-iOS-client" target="popout">[Cliente iOS]</a> <img src="/cloud/images/ext-link-8px.png" height="8px" width="8px" alt=""></li>
<li>Cloud Adventure, juego para Android basado en texto<br>
<a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-backend-java" target="popout">[Backend Java]</a> <a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-android-client" target="popout">[Cliente Android]</a> <img src="/cloud/images/ext-link-8px.png" height="8px" width="8px" alt=""></li>
</ul>
<hr></div>
</div>
</div>
<script>
(function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><script src="//www.gstatic.com/feedback/api.js">
</script><script>
$('body').delegate('.google-feedback', 'click', function() {
      userfeedback.api.startFeedback({'productId': '94614'});
  });
</script><!-- Scripts to include both on Goro + Devsite --><script>
window.___gcfg = {
     lang: ''
   };
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><!-- GTM implementation --><!-- Start dataLayer --><script>
dataLayer = [{
        'country': 'es',
        'region': 'emea',
        'language': 'es'
      }];
</script><!-- End dataLayer --><!-- Start Google Tag Manager --><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5CVQBG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <script>
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5CVQBG');
</script><!-- End Google Tag Manager --><!-- Global JS scripts to load; path will depend on whether we're on devsite or Goro --><script src="/cloud/js/base.min.js">
</script><!-- Retina loader; Do not load if partners page because we need to wait until the Angular app runs --><script>
new lfl.system.RetinaLoader();
</script><!-- Secondary right-side scroll-nav --><script>
new lfl.ui.ScrollNav({});
</script>
</body>
</html>