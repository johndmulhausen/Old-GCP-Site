<!DOCTYPE html>
<html devsite="">
<head>
<title>Mobile Articles &amp; Mobile Development Guides — Google Cloud Platform</title>
<meta name="description" content="Read technical articles on mobile solutions with Google Cloud Platform. Mobile specific articles cover application development, mobile backend and mobile gaming.">
<meta name="hide_page_heading" value="true">
<meta name="full_width" value="true">
<meta name="top_category" value="developers">
<meta name="subcategory" value="articles">
<meta name="viewport" content="initial-scale=1, minimum-scale=1, width=device-width">
<link rel="apple-touch-icon" href="//cloud.google.com/_static/images/apple-touch-icon.png">
<link href="//fonts.googleapis.com/css?family=Open+Sans:400italic,300,400,600,700" rel="stylesheet">
<link href="/css/default.css" rel="stylesheet"><!--[if lt IE 9]>
    <link rel="stylesheet" media="screen" href='/c/cp-ie.css'>
    <![endif]-->
<script src="/js/floodlight.js">
</script>
</head>
<body>
<div id="maia-main" class="cp-article">
<div class="maia-cols">
<div class="maia-col-9">
<div>
<div style="float:right">
<div class="g-plusone"></div>
</div>
<h1 class="title">Entreprises qui utilisent Google&nbsp;Cloud&nbsp;Platform</h1>
</div>
<div class="cp-article-tutorial">
<h1>Présentation</h1>
<p>Le marché des jeux pour mobile connaît une croissance fulgurante. Selon les prévisions, le chiffre d'affaires de cette industrie devrait atteindre 16&nbsp;milliards USD en 2016<sup><a href="#ftnt1" name="ftnt_ref1" id="ftnt_ref1">[1]</a></sup>. Au quatrième trimestre 2012, les dépenses mondiales liées aux achats de jeux pour le système iOS d'Apple et les plates-formes Android de Google ont même dépassé celles des jeux pour console portable<sup><a href="#ftnt2" name="ftnt_ref2" id="ftnt_ref2">[2]</a></sup>.</p>
<p>Le modèle de revenus des jeux pour mobile se déplace des&nbsp;jeux payants vers les jeux gratuits, dont les revenus sont générés par des articles virtuels, ainsi que les achats et la publicité dans les jeux. Ces nouvelles tendances s'accompagnent d'une demande pour des jeux sur mobiles à la fois plus attrayants et plus réalistes.</p>
<p>Ces jeux nécessitent non seulement une expérience utilisateur attrayante sur le client, mais aussi des services de backend enrichis et évolutifs. Google&nbsp;Cloud&nbsp;Platform vous permet de développer aisément votre backend de jeu mobile en suivant la procédure décrite dans cet article.</p>
<h2>Champ d'application</h2>
<p>Cet article s'adresse aux architectes et aux développeurs désireux de créer leurs propres backends de jeux sur mobile, et de concevoir des modèles d'interaction entre les clients mobiles et le backend.</p>
<p>La méthode et l'architecture présentées dans ce document s'appliquent au nouveau développement d'un jeu sur mobile standard. Cependant, deux autres options peuvent également se révéler pertinentes, en fonction de votre scénario et de vos besoins. La première se nomme <a href="https://developers.google.com/cloud/samples/mbs/">Mobile&nbsp;Backend&nbsp;Starter</a>. Vous pouvez envisager de l'utiliser si vous ne <a href="https://developers.google.com/cloud/samples/mbs/"></a>souhaitez pas développer votre propre backend de jeu mobile personnalisé. La deuxième option est l'architecture <a href="https://cloud.google.com/resources/articles/dedicated-server-gaming-solution">Jeu sur serveur dédié</a>. Vous pouvez l'utiliser si des serveurs de jeux dédiés sont nécessaires pour votre jeu sur mobile.</p>
<p>Cet article porte sur le développement de nouveaux jeux sur mobile hautement évolutifs sur Google&nbsp;Cloud&nbsp;Platform. L'architecture de référence des solutions pour mobile publiée <a href="https://cloud.google.com/resources/articles/mobile-application-solutions.html">ici</a> y est utilisée. Vous y trouverez cependant d'autres détails et exemples spécifiques au développement de jeux sur mobile. Cet article s'accompagne également d'un exemple de jeu sur mobile avec l'ensemble du code source.</p>
<p>Le développement de la partie client des jeux sur mobile n'est pas traité dans ce document. Vous y trouverez cependant des informations de base relatives à la communication avec le backend de jeu pour mobile, à l'authentification des utilisateurs et à l'envoi de notifications push.</p>
<h2>Conditions requises</h2>
<p>Les conditions&nbsp;généralement requises pour développer un jeu sur mobile attrayant sont décrites ci-après.</p>
<ol>
<li>Fonctionnalités du jeu&nbsp;:
<ul>
<li>Contenu dynamique du jeu</li>
<li>Données de jeu stockées en dehors de l'appareil</li>
<li>Classement</li>
<li>Mode multijoueur</li>
<li>Correspondance des joueurs</li>
<li>Génération de plateaux de jeu</li>
<li>Robots sur le site du serveur</li>
</ul>
</li>
<li>Fonctionnalités de la plate-forme&nbsp;:
<ul>
<li>Compatibilité avec les appareils Android et iOS via des applications clientes natives</li>
<li>Envoi de notifications push aux appareils Android et iOS</li>
<li>Authentification des utilisateurs</li>
<li>Évolutivité élevée</li>
</ul>
</li>
<li>Fonctionnalités commerciales
<ul>
<li>Achats dans les jeux</li>
<li>Statistiques sur le jeu</li>
</ul>
</li>
</ol>
<p>L'utilisation de Google&nbsp;Cloud&nbsp;Platform pour développer votre jeu sur mobile peut vous aider à répondre à ces exigences.</p>
<h1>Architecture des jeux sur mobile</h1>
<p>Le schéma ci-dessous (figure&nbsp;1) illustre l'architecture de haut niveau des jeux sur mobile sur Google&nbsp;Cloud&nbsp;Platform&nbsp;:</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/architecture-diag.jpg" alt="">
<figcaption>Figure&nbsp;1&nbsp;: Schéma d'architecture du jeu sur mobile proposé</figcaption>
</figure>
<h3>Vue d'ensemble</h3>
<p>Les principaux composants de l'architecture proposée pour la solution sont cités ci-après.</p>
<ul>
<li>Votre client mobile&nbsp;: toute combinaison de clients Android, iOS et HTML/JavaScript.</li>
<li>Votre application backend de jeu sur mobile.</li>
<li>La couche de communication entre les clients mobiles et le backend mobile.</li>
<li>Plusieurs services cloud destinés au stockage de vos images et données de jeu, à la diffusion de notifications push, etc.</li>
</ul>
<h3>Rôles des composants essentiels</h3>
<p>Sur le plan de la conception, vous devez choisir les fonctionnalités qui seront exécutées par chaque composant de la solution. Il s'agit notamment de déterminer les fonctionnalités qui seront mises en œuvre dans votre application cliente, ainsi que celles qui seront mises en œuvre par votre backend de jeu mobile et fournies par les services cloud.</p>
<p>Avec la montée en puissance des smartphones et des tablettes, il est pratique de mettre en œuvre autant de fonctionnalités que possible dans les clients de jeu. Le rôle principal de votre backend de jeu mobile est d'optimiser l'expérience globale, de la rendre plus attrayante et immersive, et de fournir des fonctionnalités qui n'auraient pas été possibles avec une simple application cliente.</p>
<p>De nombreux jeux sur mobile parmi les plus populaires utilisent des backends pour les opérations suivantes&nbsp;:</p>
<ul>
<li>Diffuser du contenu de jeu dynamique</li>
<li>Faciliter la mise en place de jeux multijoueur, y compris la correspondance de joueurs</li>
<li>Stocker des données hors de l'appareil mobile, par exemple le dernier niveau terminé ou les scores obtenus lors des parties précédentes</li>
<li>Gérer le classement</li>
<li>Ordonnancer les notifications push</li>
<li>Faciliter les achats dans les jeux</li>
<li>Fournir des statistiques sur le jeu</li>
</ul>
<h3>Votre backend de jeu mobile<sup><a href="#ftnt3" name="ftnt_ref3" id="ftnt_ref3">[3]</a></sup> dans le cloud</h3>
<p>En utilisant Google&nbsp;Cloud&nbsp;Platform pour optimiser votre jeu sur mobile, vous pouvez lancer votre backend de jeu sur Google&nbsp;App&nbsp;Engine, une plate-forme utilisée par <a href="https://cloud.google.com/solutions/gaming">de nombreux jeux en ligne à succès</a>, développés par des <a href="https://cloud.google.com/customers/#cp-mobile">sociétés de toutes tailles</a>. Vous disposez ainsi des avantages suivants de l'infrastructure Google&nbsp;:</p>
<ul>
<li><a href="https://developers.google.com/appengine/whyappengine#scale">Évolutivité</a> <a href="https://developers.google.com/appengine/whyappengine#scale">automatique</a></li>
<li><a href="https://developers.google.com/appengine/docs/whatisgoogleappengine#The_Application_Environment">Équilibrage automatique des charges sur les instances de votre backend mobile</a></li>
<li><a href="https://developers.google.com/appengine/docs/java/config/appconfig#Static_Files_and_Resource_Files">Diffusion et mise en cache de contenu statique</a></li>
<li><a href="http://developers.google.com/appengine/whyappengine#reliable">Fonctionnalités de sécurité, de performances et de fiabilité</a></li>
<li><a href="http://developers.google.com/appengine/docs/adminconsole/index">Contrôle et gestion</a></li>
<li><a href="https://developers.google.com/appengine/docs/java/config/dos?hl=en">Protection DoS configurable</a></li>
<li><a href="https://developers.google.com/appengine/docs/python/endpoints/auth">Intégration aux comptes Google pour l'authentification OAuth2 (pour les clients Android et iOS</a>)</li>
</ul>
<h1>Développer un jeu pour mobile sur Google&nbsp;Cloud&nbsp;Platform</h1>
<h2>Exemple de scénario de jeu</h2>
<p>L'architecture décrite dans cet article s'applique à de nombreux jeux sur mobile. Le scénario présenté ci-dessous est principalement utilisé pour rendre la conception plus spécifique. La plupart des choix opérés sur le plan de la conception conviennent également à d'autres jeux sur mobile.</p>
<h3>Griddler&nbsp;: jeu d'énigmes multijoueur pour mobile</h3>
<p>Supposons que vous deviez développer un jeu-questionnaire ou un jeu à énigmes multijoueur pour mobile appelé Griddler. Plusieurs joueurs vont se mesurer en résolvant autant d'énigmes que possible dans un laps de temps défini. Cette compétition sera désignée sous le nom d'une partie. Chaque joueur prenant part à une partie se verra présenter la même grille de lettres. En voici un exemple&nbsp;:</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/griddler.png" height="195" width="196" alt="">
<figcaption>Figure&nbsp;2&nbsp;: Capture d'écran de Griddler</figcaption>
</figure>
<p>Chaque joueur se verra proposer la même série d'énigmes pour une seule grille. La première énigme peut, par exemple, se présenter comme suit&nbsp;:</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/sample-q.png" height="396" width="222" alt="">
<figcaption>Figure&nbsp;3&nbsp;: Exemple de question sur Griddler</figcaption>
</figure>
<p>Chaque joueur doit essayer de trouver la bonne réponse, puis former le mot à l'aide de lettres adjacentes sur une grille, comme illustré sur la figure&nbsp;4.</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/answ-entry-griddler.png" height="396" width="222" alt="">
<figcaption>Figure&nbsp;4&nbsp;: Saisie de la réponse dans Griddler</figcaption>
</figure>
<p>Lorsqu'un joueur trouve le bon mot ou décide de passer une énigme, une autre énigme lui est proposée pour la même grille, comme le montre la figure&nbsp;5.</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/riddle-griddler.png" height="396" width="222" alt="">
<figcaption>Figure&nbsp;5&nbsp;: Autre exemple d'énigme dans Griddler</figcaption>
</figure>
<p>Les clients du jeu récupèrent la définition du plateau auprès du backend au début de chaque partie. De nouveaux plateaux et énigmes peuvent ainsi être ajoutés sans mettre à jour les applications clientes. L'ordre des énigmes proposées pour un plateau donné peut être fixe ou aléatoire. La définition de plateau récupérée comprend les énigmes correspondant à ce plateau, ainsi que le temps alloué pour une partie. À la fin du temps imparti, le joueur qui a résolu le plus d'énigmes a gagné. En cas d'égalité, la victoire revient au joueur qui a résolu les énigmes le plus rapidement.</p>
<p>À tout moment, plusieurs millions de parties peuvent être en cours, le nombre de joueurs par partie pouvant varier de 1 à N. Griddler propose également un mode solo qui peut être utilisé pour comprendre le fonctionnement du jeu ou simplement pour le plaisir de résoudre des énigmes.</p>
<p>Outre la diffusion de définitions de plateau aux clients, le backend de jeu mobile effectue les opérations suivantes&nbsp;:</p>
<ul>
<li>Gestion de la liste des utilisateurs et de leurs statistiques (nombre de parties jouées par l'utilisateur sur différents appareils, nombre de parties remportées en mode multijoueur, etc.)</li>
<li>Gestion de la liste des appareils utilisés par les joueurs, dans le but d'envoyer des notifications push vers ces appareils</li>
<li>Envoi d'invitations pour des parties en mode multijoueur</li>
<li>Transmission de l'acceptation de l'invitation, des refus et des annulations</li>
</ul>
<h2>Composants principaux des jeux sur mobile</h2>
<p>Vous pouvez facilement mettre en œuvre Griddler et d'autres jeux pour mobile sur l'architecture décrite dans cet article. Les clients peuvent être mis en œuvre en tant qu'applications iOS et Android natives. Le backend de jeu mobile peut fonctionner sur Google&nbsp;App&nbsp;Engine. Vous pouvez utiliser Google&nbsp;Cloud&nbsp;Endpoints pour présenter l'API à partir du backend mobile et l'exploiter à partir des clients.</p>
<h3>Applications clientes du jeu sur mobile</h3>
<p>Toutes les interactions avec l'utilisateur et l'interface utilisateur sont effectuées par les applications clientes Android et iOS, au même titre que le fonctionnement du jeu. La conception de cette fonctionnalité n'est pas très différente de celle d'un jeu pour mobile qui n'utilise aucun backend de jeu mobile. Par conséquent, elle n'est pas traitée dans le présent document.</p>
<p>Dans le cas de Griddler, la différence réside dans le fait que les clients sont optimisés par un backend de jeu mobile. Le client communique avec le backend pour faciliter les jeux en mode multijoueur et la correspondance des joueurs. Cela inclut la gestion des notifications push reçues avec les invitations de jeu envoyés par le backend. Le client récupère également du backend tout contenu de jeu dynamique, tel qu'une définition de plateau pour un jeu donné. Cela comprend la grille de lettres et toutes les énigmes d'une grille donnée, ainsi que les bonnes réponses.</p>
<p>Une fois la partie commencée, que ce soit en mode solo ou multijoueur, aucune communication avec le backend n'est requise jusqu'à la fin de la partie. Le client envoie alors les résultats de la partie au backend de jeu mobile qui les stocke et désigne le vainqueur, dans le cas d'une partie multijoueur.</p>
<h3>Backend de jeu mobile</h3>
<p>Le backend de jeu mobile doit présenter l'API appropriée pour que le client active le fonctionnement et l'environnement de jeu souhaités.</p>
<p>L'API Griddler comprend des méthodes pour les éléments suivants&nbsp;:</p>
<ul>
<li>Gestion du jeu&nbsp;; startNewSinglePlayerGame (qui récupère, entre autres, une définition de plateau) et gameFinished, par exemple.</li>
<li>Invitations de joueurs&nbsp;; sendInvitation, acceptInvitation, etc.</li>
<li>Notifications&nbsp;; registerDeviceForPushNotification, par exemple.</li>
</ul>
<p>Ces méthodes peuvent être proposées aux clients selon la procédure décrite dans la <a href="#cbym">section suivante</a>.</p>
<p>Lors du traitement de demandes API synchrones, le backend mobile <a href="#storedata">stocke, récupère et gère les données dans une mémoire persistante.</a> Pour les données fréquemment utilisées, telles que les définitions de plateau, une <a href="#odawm">mémoire cache</a> est également utilisée.</p>
<p>Outre le traitement des demandes en provenance du client, le backend mobile se charge du <a href="#odawm">traitement asynchrone</a> requis par le jeu sur mobile, de l'<a href="#pushnotifications">ordonnancement des notifications push</a>, de la gestion des <a href="#scheduled">tâches planifiées</a>, etc.</p>
<a name="cbym" id="cbym"></a>
<h3>Communication entre les clients du jeu sur mobile et le backend mobile</h3>
<p>Comme indiqué dans l'<a href="https://cloud.google.com/resources/articles/mobile-application-solutions">article traitant des solutions pour mobile</a>, l'utilisation de <a href="https://developers.google.com/appengine/docs/java/endpoints/overview">Google&nbsp;Cloud&nbsp;Endpoints</a><sup><a href="#ftnt4" name="ftnt_ref4" id="ftnt_ref4">[4]</a></sup> est recommandée pour présenter l'API en provenance du backend mobile et l'utiliser à partir du client mobile. Cette technologie vous permet, en effet, de définir votre API au moyen d'annotations simples dans votre code source et d'utiliser des outils pour générer des bibliothèques clientes Android et iOS à typage fort, ainsi que du code JavaScript pour interagir avec votre API à partir de clients Web. Elle accepte également l'authentification basée sur OAuth2 avec les comptes Google, de sorte que le code de votre backend de jeu mobile puisse connaître l'identité du joueur.</p>
<p>Dans Griddler, par exemple, la méthode d'envoi d'une invitation est déclarée comme suit&nbsp;:</p>
<pre>
@ApiMethod(httpMethod = "PUT", path ="game/{gameId}/invitation/{playerId}")
public InvitationResult sendInvitation(@Named("gameId") Long gameId,
 @Named("playerId") Long playerId, User user) throws ServiceException { }
</pre>
<p>Le code ci-dessus déclare API sendInvitation qui sera représentée sous la forme d'une requête HTTP PUT à l'aide de l'URL spécifiée dans l'argument "path". Les arguments "gameId" et "playerId" sont transmis explicitement par le client. L'objet utilisateur est renseigné par l'infrastructure Google&nbsp;Cloud&nbsp;Endpoints sur la base des informations d'authentification fournies implicitement par le client. Pour plus d'informations sur l'annotation @Api, consultez la <a href="https://developers.google.com/appengine/docs/java/endpoints/annotations"></a><a href="https://developers.google.com/appengine/docs/java/endpoints/annotations">documentation</a> de Cloud&nbsp;Endpoints.</p>
<p>Lorsque les outils Google&nbsp;Endpoints sont utilisés pour générer des bibliothèques clientes, il suffit à votre client Android d'effectuer un simple appel pour accéder à cette API affichée à partir de votre backend mobile&nbsp;:</p>
<pre>
InvitationResult invitationResult = gameBackend.sendInvitation(
gameId, playerId)).execute();
</pre>
<p>En règle générale, un appel doit être exécuté de manière asynchrone pour éviter le blocage des appels réseau sur le fil d'interface utilisateur.</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/communication.png" height="341" width="579" alt="">
<figcaption>Figure 6. Communication entre le client de jeu sur mobile et le backend mobile</figcaption>
</figure>
<a name="storedata" id="storedata"></a>
<h3>Stockage de données<sup><a href="#ftnt5" name="ftnt_ref5" id="ftnt_ref5">[5]</a></sup></h3>
<p>Les jeux sur mobiles attrayants et réalistes doivent généralement stocker des données hors de l'appareil client.</p>
<p>Certains jeux sur mobile peuvent utiliser du contenu dynamique représenté sous la forme de grands objets généralement binaires. Cela inclut des images qui définissent les parties d'un monde de jeu virtuel ou des avatars importés par les joueurs. Pour ce type de données, vous pouvez utiliser <a href="http://developers.google.com/storage/docs/getting-started">Google&nbsp;Cloud&nbsp;Storage</a>, un service qui permet de stocker des objets et des fichiers dont la taille peut atteindre plusieurs téraoctets. Reportez-vous également à la section "<a href="#sapi">Diffusion et traitement d'images</a>" ci-dessous.</p>
<p>Les autres types de données qui doivent être stockés hors de l'appareil client sont des entités et des propriétés avancées. Ces propriétés et entités peuvent inclure des informations sur le niveau le plus élevé atteint dans un jeu sur mobile, ainsi que d'autres informations sur les joueurs, telles que leurs surnoms, l'enregistrement de leur appareil pour l'envoi de notifications push, l'historique de leurs achats dans les jeux et d'autres données spécifiques au jeu.</p>
<p>Les propriétés de ces entités peuvent également inclure une référence aux objets stockés dans Google&nbsp;Cloud&nbsp;Storage, comme le nom de l'objet et, éventuellement, un nom d'ensemble ou une URL.</p>
<p>Lorsque votre backend mobile est hébergé sur Google&nbsp;App&nbsp;Engine, <a href="https://developers.google.com/datastore/">Cloud&nbsp;Datastore</a> est l'emplacement recommandé pour stocker des entités de ce type. Il met à votre disposition un magasin de données sans schéma NoSQL<sup><a href="#ftnt6" name="ftnt_ref6" id="ftnt_ref6">[6]</a></sup> hautement évolutif, avec un moteur de requêtes et des transactions atomiques.</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/storing-data.jpg" height="350" width="305" alt="">
<figcaption>Figure&nbsp;7&nbsp;: Stockage de données</figcaption>
</figure>
<p>Dans Griddler, par exemple, les entités principales sont les suivantes&nbsp;:</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/key-entities.jpg" alt="">
<figcaption>Figure&nbsp;8&nbsp;: Entités principales dans Griddler</figcaption>
</figure>
<ul>
<li>Player</li>
<li>Board&nbsp;: définition d'une grille de jeu et énigmes à résoudre pour cette grille</li>
<li>Game&nbsp;: instance d'un ou de plusieurs joueurs qui s'affrontent pour résoudre des énigmes sur un plateau donné</li>
<li>Invitation&nbsp;: entité utilisée pour lancer des parties en mode multijoueur</li>
<li>GamePlay&nbsp;: entité représentant l'état et les résultats d'une partie disputée par un joueur. Dans le cas des parties en mode multijoueur, il existe plusieurs entités GamePlay pour une entité Game donnée (une par entité Player).</li>
<li>Device&nbsp;: informations spécifiques à la plate-forme nécessaires pour envoyer des notifications push à un appareil donné (par exemple, jeton d'appareil pour iOS et identifiant d'enregistrement GCM pour Android).</li>
</ul>
<p>Pour permettre une cohérence forte, les entités Invitation et GamePlay appartiennent au <a href="https://developers.google.com/appengine/docs/java/gettingstarted/usingdatastore?hl=en">groupe d'entités</a> situé à la racine de l'entité ascendante Game. De même, l'entité Device appartient au groupe d'entités situé à la racine de l'entité ascendante Player.</p>
<p>L'utilisation de Datastore pour stocker les entités permet de faire évoluer aisément vos jeux sur mobile de manière à accepter des millions de joueurs.</p>
<p>Les données utilisées par Griddler dans la mise en œuvre actuelle ne sont ni volumineuses ni binaires. Elles sont donc toutes stockées dans Datastore. Cependant, si des améliorations ont été mises en œuvre pour fournir des indices visuels pour la résolution des énigmes ou pour autoriser les utilisateurs à importer leurs avatars, Griddler peut utiliser Google&nbsp;Cloud&nbsp;Storage pour stocker des images.</p>
<a name="odawm" id="odawm"></a>
<h3>Optimisation de l'accès aux données avec Memcache</h3>
<p>Lorsque la charge augmente, votre backend de jeu mobile peut être composé de milliers d'instances individuelles traitant des demandes. Si vos clients adressent fréquemment au backend des demandes portant sur la récupération des mêmes données, l'accès peut être optimisé afin d'éviter de récupérer les données à partir du stockage persistant pour chaque demande.</p>
<p>Un backend qui exécute Google&nbsp;App&nbsp;Engine peut utiliser un service de cache de données en mémoire distribué appelé <a href="http://developers.google.com/appengine/docs/java/memcache/">Memcache</a> pour stocker et récupérer les données auxquelles les utilisateurs accèdent fréquemment (Figure&nbsp;9). L'utilisation de Memcache améliore non seulement les performances et l'évolutivité de votre backend de jeu mobile, mais elle permet également de réduire les coûts d'accès à App&nbsp;Engine&nbsp;Datastore, dans la mesure où votre application adressera moins de demandes à ce magasin de données.</p>
<p>Plusieurs millions d'utilisateurs peuvent, par exemple, jouer simultanément à Griddler et il se peut que plusieurs centaines de milliers d'entre eux résolvent, en même temps, des énigmes d'un même plateau (grille de lettres). Dans ce cas, il est judicieux de mettre les définitions de plateau en cache, plutôt que de les récupérer à chaque fois.</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/optimizing-data.jpg" height="421" width="352" alt="">
<figcaption>Figure&nbsp;9&nbsp;: Optimisation de l'accès aux données avec Memcache</figcaption>
</figure>
<h3>Traitement asynchrone avec les files d'attente de tâches</h3>
<p>Dans certains cas, il n'est pas possible, ou souhaitable, d'effectuer toutes les tâches associées à une demande provenant d'un client de jeu mobile avant que la réponse ne soit renvoyée à l'appareil de l'utilisateur.</p>
<p>Par exemple, pour rendre le jeu plus attrayant et davantage axé sur les réseaux sociaux, Griddler peut être équipé d'une fonctionnalité qui informe les amis du joueur lorsque ce dernier obtient un score très élevé et apparaît dans le classement. Cette fonctionnalité peut être déclenchée lorsque le client appelle l'API gameFinished. Il convient toutefois de tenir compte du fait qu'un joueur peut avoir de nombreux amis et que le client ne doit pas être bloqué tant qu'ils n'ont pas tous été informés. Non seulement une conception synchrone de ce type bloquerait le client, mais en plus, elle ne serait pas fiable. Une autre solution existe dans le cadre de l'API gameFinished&nbsp;: votre backend de jeu mobile peut stocker les résultats du jeu, tenir compte de la nécessité de traiter les notifications et renvoyer immédiatement la réponse au client sans attendre que toutes les notifications aient été traitées.</p>
<p>Le code qui s'exécute sur Google&nbsp;App&nbsp;Engine peut utiliser un service baptisé <a href="http://developers.google.com/appengine/docs/java/taskqueue/">Task Queues</a> pour placer en file d'attente les informations relatives aux tâches qui doivent être exécutées de manière asynchrone. Dans l'exemple mentionné précédemment, votre application peut mettre une tâche en file d'attente pour informer les amis du joueur que ce dernier a intégré le Top&nbsp;20.</p>
<p>En règle générale, vous configurez le service "Task&nbsp;Queues" de manière à envoyer les tâches placées en file d'attente (<a href="http://developers.google.com/appengine/docs/java/taskqueue/overview-push">modèle push</a>) à votre code exécuté sur Google&nbsp;App&nbsp;Engine sous la forme de requêtes HTTP adressées à une URL spécifique. Votre backend de jeu mobile peut traiter ces requêtes au moyen de gestionnaires de requêtes Web standards. Dans l'exemple ci-dessus, votre gestionnaire de requêtes peut récupérer les informations sur les tâches à partir de la requête HTTP, rechercher les amis du joueur, puis informer chacun d'eux, soit en créant des publications sur un site de réseaux sociaux, soit en envoyant des notifications push comme il est décrit <a href="#pushnotifications">ci-dessous</a>.</p>
<p>Votre code peut également <a href="http://developers.google.com/appengine/docs/java/taskqueue/overview-pull">extraire les</a> <a href="http://developers.google.com/appengine/docs/java/taskqueue/overview-pull">tâches</a> des files d'attente. Cela peut se révéler utile si vous souhaitez, par exemple, contrôler explicitement le traitement des tâches. Les tâches de retrait sont également adaptées au traitement des tâches en dehors d'App&nbsp;Engine&nbsp;; par exemple, par des instances Google&nbsp;Compute&nbsp;Engine, comme il est décrit dans l'<a href="https://cloud.google.com/resources/articles/mobile-application-solutions">article traitant des</a> <a href="https://cloud.google.com/resources/articles/mobile-application-solutions">solutions</a><a href="https://cloud.google.com/resources/articles/mobile-application-solutions">pour mobile</a>.</p>
<a name="pushnotifications" id="pushnotifications"></a>
<h3>Notifications push</h3>
<p>Les notifications push permettent aux backends de jeu de communiquer aux clients les modifications d'état et d'autres informations pertinentes, sans que ceux-ci n'aient à les interroger en permanence. Elles peuvent être utilisées pour garantir une expérience utilisateur idéale, tout en optimisant l'utilisation de la batterie et de la bande passante. Selon la plate-forme cliente, votre jeu pour mobile peut utiliser cette technologie pour afficher des "<a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html">toast</a><a href="http://developer.android.com/guide/topics/ui/notifiers/toasts.html">s</a>" et d'autres notifications sur les appareils des utilisateurs, même si votre client de jeu n'est pas actif. Elle peut également être utilisée pour continuer à alimenter le client de jeu en données pertinentes.</p>
<p>Dans Griddler, les notifications push sont utilisées pour envoyer des invitations lorsqu'un utilisateur désire affronter l'un de ses amis. Elles permettent d'inviter des personnes qui n'exécutent pas actuellement le jeu sur leur appareil.</p>
<p>Lorsque votre code de backend mobile s'exécute sur Google&nbsp;App&nbsp;Engine, vous pouvez organiser l'envoi de notifications push aux utilisateurs en tirant parti des technologies suivantes&nbsp;:</p>
<ul>
<li><a href="http://developer.android.com/google/gcm/index.html">Google&nbsp;Cloud&nbsp;Messaging</a> pour Android (GCM)&nbsp;: ce service Google vous permet d'envoyer des données aux utilisateurs qui ont installé votre jeu pour mobile sur leurs appareils Android. Si vous utilisez Eclipse, vous pouvez faire en sorte que le code schématique soit généré par le <a href="http://developers.google.com/eclipse/">plug-in Google pour Eclipse</a>.</li>
<li>API Sockets<sup><a href="#ftnt7" name="ftnt_ref7" id="ftnt_ref7">[7]</a></sup> pour envoyer des notifications push aux utilisateurs iOS à l'aide d'Apple® Push Notification Service. Pour commencer, nous vous invitons à lire un article traitant de l'<a href="https://cloud.google.com/resources/articles/ios-push-notifications">ordonnancement des notifications push&nbsp;iOS sur Google&nbsp;Cloud&nbsp;Platform</a> et à analyser l'<a href="https://github.com/GoogleCloudPlatform/solutions-ios-push-notification-sample-backend-java">exemple de code publié sur Github</a>.</li>
</ul>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/push-notification.png" height="438" width="457" alt="">
<figcaption>Figure&nbsp;10&nbsp;: Notification push</figcaption>
</figure>
<a name="sapi" id="sapi"></a>
<h3>Diffusion et traitement d'images</h3>
<p>Certaines images statiques, telles que les différentes icônes qui composent votre jeu et sont utilisées pour créer l'interface utilisateur de votre application cliente, peuvent être empaquetées, souvent dans plusieurs résolutions, dans vos clients de jeu Android et iOS natifs. Cependant, cela entraîne une augmentation de la&nbsp;taille du package. Un package volumineux risque de dissuader les utilisateurs de télécharger votre application. Cela peut également les inciter à la désinstaller dès que l'espace vient à manquer sur leur appareil.</p>
<p>Dans la majorité des cas, empaqueter dans une application cliente toutes les images dont un jeu a besoin s'avère peu pratique, voire impossible. Il se peut, par exemple, que votre jeu se compose de mondes virtuels étendus et/ou dynamiques, avec un graphisme particulièrement détaillé, représentés sous la forme d'images dont la taille totale peut atteindre des centaines de mégaoctets ou plusieurs gigaoctets. Même si les images sont plus légères, vous voulez avoir la possibilité d'ajouter de nouveaux graphiques sans forcer les utilisateurs à mettre à jour leurs applications clientes.</p>
<p>Il est, par exemple, possible d'étendre les fonctionnalités de Griddler afin d'inclure une indication visuelle pour résoudre une énigme proposée, ou encore d'autoriser les joueurs à importer des images représentant leurs avatars.</p>
<p>Si vous pouvez préparer de telles images dans des résolutions et des formats optimisés pour vos clients de jeu mobiles, vous pouvez les importer dans <a href="http://developers.google.com/storage/docs/getting-started">Google&nbsp;Cloud&nbsp;Storage</a>, puis fournir aux clients des URL pointant directement vers ces images. Cette méthode se révèle particulièrement évolutive, en ce sens qu'elle permet aux clients mobiles de récupérer directement ces images depuis l'espace de stockage évolutif dans le cloud sans utiliser le code de votre backend mobile.</p>
<p>Dans certains cas, vous pouvez manipuler et traiter des images, en plus de les stocker. Vous pouvez, par exemple, diffuser les images dans des formats adaptés dynamiquement en fonction de la résolution de vos appareils clients. Vous pouvez alors utiliser le <a href="https://developers.google.com/appengine/docs/java/images/">service Images</a> de Google&nbsp;App&nbsp;Engine pour redimensionner, faire pivoter, retourner et recadrer des images, ainsi que pour améliorer des photos à l'aide d'un algorithme prédéfini. Ces opérations peuvent être effectuées sur des images provenant de Google&nbsp;Cloud&nbsp;Storage et d'autres sources. Une fois modifiées, les images peuvent être distribuées directement aux clients à partir de l'infrastructure de diffusion d'images dynamique fournie par Google, sans que le code de votre backend de jeu mobile ne soit utilisé. Le rôle de votre code se limite à l'utilisation de l'API Images&nbsp;Service afin d'obtenir l'URL d'image appropriée et à la transmission de cette URL aux clients mobiles.</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/serving-processing-imgs.jpg" height="373" width="467" alt="">
<figcaption>Figure&nbsp;11&nbsp;: Diffusion et traitement d'images</figcaption>
</figure>
<a name="scheduled" id="scheduled"></a>
<h3>Tâches planifiées</h3>
<p>Le code de votre backend de jeu mobile traite les demandes en provenance des clients mobiles de manière synchrone via Google&nbsp;Cloud&nbsp;Endpoints et asynchrone via Task&nbsp;Queues. Il arrive qu'il doive, en outre, procéder à un traitement selon des intervalles réguliers ou semi-réguliers. Vous pouvez, par exemple, faire en sorte que votre backend de jeu mobile envoie des notifications push aux personnes qui n'ont plus joué depuis plusieurs jours et les incite ainsi à faire une nouvelle partie. Vous souhaitez, en outre, que ce processus soit exécuté à des moments bien précis.</p>
<p>Votre backend de jeu mobile peut également mettre à jour des données en cache dans Memcache toutes les 5&nbsp;minutes ou actualiser les statistiques des meilleurs joueurs toutes les 15&nbsp;minutes.</p>
<p>Lorsque le code de votre backend de jeu mobile s'exécute sur Google&nbsp;App&nbsp;Engine, le <a href="http://developers.google.com/appengine/docs/java/config/cron">service&nbsp;Cron</a> permet de configurer aisément ces tâches planifiées. Vous pouvez le configurer de manière à appeler certaines URL de votre backend mobile à des intervalles définis ou à des heures bien précises.</p>
<figure><img src="../images/articles/developing-mobile-games-on-gcp/scheduled-jobs.jpg" height="282" width="412" alt="">
<figcaption>Figure&nbsp;12&nbsp;: Tâches planifiées avec le service Cron</figcaption>
</figure>
<h2>Services Google&nbsp;Play&nbsp;Jeux</h2>
<p>Les <a href="https://developers.google.com/games/services/">services Google&nbsp;Play&nbsp;Jeux</a> vous permettent de renforcer facilement le caractère social de vos jeux Web, iOS et Android. Vous pouvez récompenser les joueurs les plus méritants, susciter l'engouement au moyen de classements, ou encore rendre votre jeu plus dynamique en permettant à plusieurs joueurs de s'affronter ou de coopérer simultanément.</p>
<h2>Exemples d'application</h2>
<p>Vous pouvez télécharger l'exemple d'application Griddler sur <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-backend-java">Github</a>. Le backend mobile est mis en œuvre en langage Java et présente l'API&nbsp;REST à l'aide de Cloud&nbsp;Endpoints. Les données sont stockées dans Datastore à l'aide d'une API de bas niveau et des notifications push sont envoyées. Les clients de jeu <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-android-client">Android</a> et <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-iOS-client">iOS</a> sont mis en œuvre sous la forme d'applications natives. La communication entre les clients et le backend de jeu mobile est authentifiée à l'aide du protocole OAuth et des comptes Google.</p>
<p>Vous pouvez également télécharger <a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-backend-java">Cloud&nbsp;Adventure</a>, un autre jeu pour mobile développé sur une architecture semblable. Cloud&nbsp;Adventure est un <a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-android-client">jeu en mode texte pour Android</a> qui présente quelques scénarios intéressants, tels qu'un hall pour plusieurs joueurs et une méthode de sélection de pseudo unique. Il montre également comment combiner Google&nbsp;Cloud&nbsp;Messaging pour Android et Cloud&nbsp;Endpoints afin de gérer la fin d'un jeu et le comptage des points.</p>
<h2>Étapes suivantes</h2>
<p>Si nécessaire, rendez-vous sur le portail de <a href="https://cloud.google.com/">Google&nbsp;Cloud&nbsp;Platform</a> et cliquez sur le lien "Try it Now" (Essayer maintenant). Vous pourrez alors suivre la procédure de création d'un projet Google&nbsp;Cloud gratuit, que vous pourrez utiliser pour <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-backend-java">déployer</a> l'exemple de jeu Griddler. Vous aurez ensuite la possibilité de jouer avec ce jeu, de l'explorer et de l'enrichir en ajoutant, par exemple, un indice visuel à chaque énigme.</p>
<h2>Conclusion</h2>
<p>Google&nbsp;Cloud&nbsp;Platform vous permet de créer aisément un backend mobile pour vos jeux. Vous pouvez vous concentrer sur le développement de votre jeu, sans devoir vous préoccuper du déploiement, de la gestion et du dépannage de l'infrastructure informatique. Vous pouvez développer des jeux pour mobile attrayants et réalistes, capables d'évoluer aisément au gré de l'engouement qu'ils suscitent auprès des utilisateurs du monde entier.</p>
<p>De nombreux <a href="https://cloud.google.com/solutions/gaming">jeux à succès</a> utilisent déjà Google&nbsp;Cloud&nbsp;Platform. Qu'attendez-vous pour franchir le pas&nbsp;? Nous sommes impatients de lire votre témoignage.</p>
<br>
<hr>
<p><a href="#ftnt_ref1" name="ftnt1" id="ftnt1">[1]</a> Voir <a href="http://www.abiresearch.com/press/mobile-gaming-revenues-will-exceed-16-billion-in-2">http://www.abiresearch.com/press/mobile-gaming-revenues-will-exceed-16-billion-in-2</a></p>
<p><a href="#ftnt_ref2" name="ftnt2" id="ftnt2">[2]</a> Voir <a href="http://blog.appannie.com/app-annie-idc-portable-gaming-report/#ixzz2MczOY0l8">http://blog.appannie.com/app-annie-idc-portable-gaming-report/#ixzz2MczOY0l8</a></p>
<p><a href="#ftnt_ref3" name="ftnt3" id="ftnt3">[3]</a> Dans cet article, le terme "backend" désigne, d'une manière générale, la partie de la solution pour mobile qui s'exécute en dehors des appareils clients, à ne pas confondre avec les <a href="http://developers.google.com/appengine/docs/java/backends/overview?hl=en">instances de backend</a> Google&nbsp;App&nbsp;Engine.</p>
<p><a href="#ftnt_ref4" name="ftnt4" id="ftnt4">[4]</a> Depuis le mois de juin&nbsp;2013, Google&nbsp;Cloud&nbsp;Endpoints est une fonctionnalité disponible à titre expérimental.</p>
<p><a href="#ftnt_ref5" name="ftnt5" id="ftnt5">[5]</a> La section&nbsp;4.2 des <a href="https://developers.google.com/appengine/terms">Conditions d'utilisation de Google&nbsp;App&nbsp;Engine</a> décrit votre obligation de protéger la vie privée et les droits de vos utilisateurs finaux. Cela comprend l'obligation de fournir des règles de confidentialité adéquates sur le plan juridique concernant l'utilisation des données collectées et l'obtention de tous les consentements nécessaires auprès des utilisateurs finaux pour ce qui concerne la collecte, l'utilisation, le contrôle ou la divulgation de ces données.</p>
<p><a href="#ftnt_ref6" name="ftnt6" id="ftnt6">[6]</a> Si vous préférez utiliser une base de données SQL relationnelle, vous pouvez opter pour <a href="http://developers.google.com/cloud-sql/">Google&nbsp;Cloud&nbsp;SQL</a> <a href="http://developers.google.com/cloud-sql/faq#choice">en remplacement ou en plus de Datastore</a>.</p>
<p><a href="#ftnt_ref7" name="ftnt7" id="ftnt7">[7]</a> Depuis le mois de juin&nbsp;2013, l'API&nbsp;Sockets est une fonctionnalité disponible à titre expérimental.</p>
</div>
<!-- /maia-main --></div>
<div class="maia-col-3"><br>
<img src="//www.google.com/images/icons/product/feedback-16.png" class="g-app-icon" alt=""> <a href="javascript:void(0);" class="google-feedback">Commentaires sur ce document</a><br>
<br>
<hr>
<h4>Exemples d'application</h4>
<ul>
<li>Jeu multijoueur pour mobile Griddler<br>
<a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-backend-java" target="popout">[Backend Java]</a> <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-android-client" target="popout">[Client Android]</a> <a href="https://github.com/GoogleCloudPlatform/solutions-griddler-sample-iOS-client" target="popout">[Client iOS]</a> <img src="../images/ext-link-8px.png" height="8px" width="8px" alt=""></li>
<li>Jeu en mode texte pour Android Cloud&nbsp;Adventure<br>
<a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-backend-java" target="popout">[Backend Java]</a> <a href="https://github.com/GoogleCloudPlatform/solutions-cloud-adventure-sample-android-client" target="popout">[Client Android]</a> <img src="../images/ext-link-8px.png" height="8px" width="8px" alt=""></li>
</ul>
<hr></div>
</div>
</div>
<script>
(function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><script src="//www.gstatic.com/feedback/api.js">
</script><script>
$('body').delegate('.google-feedback', 'click', function() {
      userfeedback.api.startFeedback({'productId': '94614'});
  });
</script><!-- Scripts to include both on Goro + Devsite --><script>
window.___gcfg = {
     lang: ''
   };
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script><!-- GTM implementation --><!-- Start dataLayer --><script>
dataLayer = [{
        'country': 'fr',
        'region': 'emea',
        'language': 'fr'
      }];
</script><!-- End dataLayer --><!-- Start Google Tag Manager --><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5CVQBG" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <script>
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5CVQBG');
</script><!-- End Google Tag Manager --><!-- Global JS scripts to load; path will depend on whether we're on devsite or Goro --><script src="/js/base.min.js">
</script><!-- Retina loader; Do not load if partners page because we need to wait until the Angular app runs --><script>
new lfl.system.RetinaLoader();
</script><!-- Secondary right-side scroll-nav --><script>
new lfl.ui.ScrollNav({});
</script>
</body>
</html>